{
  "contracts": [
    {
      "name": "src",
      "path": "events/event-def2/src/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::event]\npub struct EventDefAnotherCrate {\n    #[ink(topic)]\n    pub hash: [u8; 32],\n    #[ink(topic)]\n    pub maybe_hash: Option<[u8; 32]>,\n}\n"
    },
    {
      "name": "events",
      "path": "events/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::event(anonymous)]\npub struct AnonymousEvent {\n    #[ink(topic)]\n    pub topic: [u8; 32],\n    pub field_1: u32,\n}\n\n#[ink::contract]\npub mod events {\n    #[ink(storage)]\n    pub struct Events {\n        value: bool,\n    }\n\n    #[ink(event)]\n    pub struct InlineFlipped {\n        value: bool,\n    }\n\n    #[ink(\n        event,\n        signature_topic = \"1111111111111111111111111111111111111111111111111111111111111111\"\n    )]\n    pub struct InlineCustomFlipped {\n        value: bool,\n    }\n\n    #[ink(event)]\n    #[ink(anonymous)]\n    pub struct InlineAnonymousEvent {\n        #[ink(topic)]\n        pub topic: [u8; 32],\n        pub field_1: u32,\n    }\n\n    impl Events {\n        /// Creates a new events smart contract initialized with the given value.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Flips the current value of the boolean.\n        #[ink(message)]\n        pub fn flip_with_foreign_event(&mut self) {\n            self.value = !self.value;\n            self.env()\n                .emit_event(event_def::ForeignFlipped { value: self.value })\n        }\n\n        /// Flips the current value of the boolean.\n        #[ink(message)]\n        pub fn flip_with_inline_event(&mut self) {\n            self.value = !self.value;\n            self.env().emit_event(InlineFlipped { value: self.value })\n        }\n\n        /// Flips the current value of the boolean.\n        #[ink(message)]\n        pub fn flip_with_inline_custom_event(&mut self) {\n            self.value = !self.value;\n            self.env()\n                .emit_event(InlineCustomFlipped { value: self.value })\n        }\n\n        /// Emit an event with a 32 byte topic.\n        #[ink(message)]\n        pub fn emit_32_byte_topic_event(&self, maybe_hash: Option<[u8; 32]>) {\n            self.env().emit_event(event_def::ThirtyTwoByteTopics {\n                hash: [0x42; 32],\n                maybe_hash,\n            })\n        }\n\n        /// Emit an event from a different crate.\n        #[ink(message)]\n        pub fn emit_event_from_a_different_crate(&self, maybe_hash: Option<[u8; 32]>) {\n            self.env().emit_event(event_def2::EventDefAnotherCrate {\n                hash: [0x42; 32],\n                maybe_hash,\n            })\n        }\n\n        /// Emit a inline and standalone anonymous events\n        #[ink(message)]\n        pub fn emit_anonymous_events(&self, topic: [u8; 32]) {\n            self.env()\n                .emit_event(InlineAnonymousEvent { topic, field_1: 42 });\n            self.env()\n                .emit_event(super::AnonymousEvent { topic, field_1: 42 });\n        }\n    }\n\n    /// Implementing the trait from the `event_def_unused` crate includes all defined\n    /// events there.\n    impl event_def_unused::FlipperTrait for Events {\n        #[ink(message)]\n        fn flip(&mut self) {\n            self.value = !self.value;\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use ink::scale::Decode as _;\n\n        #[test]\n        fn collects_specs_for_all_linked_and_used_events() {\n            let event_specs = ink::metadata::collect_events();\n            assert_eq!(8, event_specs.len());\n\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"ForeignFlipped\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"InlineFlipped\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"InlineCustomFlipped\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"ThirtyTwoByteTopics\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"EventDefAnotherCrate\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"AnonymousEvent\"));\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"InlineAnonymousEvent\"));\n\n            // The event is not used in the code by being included in the metadata\n            // because we implement trait form `event_def_unused` crate.\n            assert!(event_specs\n                .iter()\n                .any(|evt| evt.label() == &\"EventDefUnused\"));\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut events = Events::new(false);\n            events.flip_with_foreign_event();\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n            let event = &emitted_events[0];\n\n            let decoded_event = <event_def::ForeignFlipped>::decode(&mut &event.data[..])\n                .expect(\"encountered invalid contract event data buffer\");\n            assert!(decoded_event.value);\n        }\n\n        #[ink::test]\n        fn option_topic_some_has_topic() {\n            let events = Events::new(false);\n            events.emit_32_byte_topic_event(Some([0xAA; 32]));\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n            let event = &emitted_events[0];\n\n            assert_eq!(event.topics.len(), 3);\n            let signature_topic =\n                <event_def::ThirtyTwoByteTopics as ink::env::Event>::SIGNATURE_TOPIC\n                    .map(|topic| topic.to_vec());\n            assert_eq!(Some(&event.topics[0]), signature_topic.as_ref());\n            assert_eq!(event.topics[1], [0x42; 32]);\n            assert_eq!(\n                event.topics[2], [0xAA; 32],\n                \"option topic should be published\"\n            );\n        }\n\n        #[ink::test]\n        fn option_topic_none_encoded_as_0() {\n            let events = Events::new(false);\n            events.emit_32_byte_topic_event(None);\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n            let event = &emitted_events[0];\n\n            let signature_topic =\n                <event_def::ThirtyTwoByteTopics as ink::env::Event>::SIGNATURE_TOPIC\n                    .map(|topic| topic.to_vec())\n                    .unwrap();\n\n            let expected_topics = vec![\n                signature_topic,\n                [0x42; 32].to_vec(),\n                [0x00; 32].to_vec(), // None is encoded as 0x00\n            ];\n            assert_eq!(expected_topics, event.topics);\n        }\n\n        #[ink::test]\n        fn custom_signature_topic() {\n            let mut events = Events::new(false);\n            events.flip_with_inline_custom_event();\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n\n            let signature_topic =\n                <InlineCustomFlipped as ink::env::Event>::SIGNATURE_TOPIC;\n\n            assert_eq!(Some([17u8; 32]), signature_topic);\n        }\n\n        #[ink::test]\n        fn anonymous_events_emit_no_signature_topics() {\n            let events = Events::new(false);\n            let topic = [0x42; 32];\n            events.emit_anonymous_events(topic);\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(2, emitted_events.len());\n\n            let event = &emitted_events[0];\n            assert_eq!(event.topics.len(), 1);\n            assert_eq!(event.topics[0], topic);\n\n            let event = &emitted_events[1];\n            assert_eq!(event.topics.len(), 1);\n            assert_eq!(event.topics[0], topic);\n\n            let signature_topic =\n                <InlineAnonymousEvent as ink::env::Event>::SIGNATURE_TOPIC;\n            assert_eq!(None, signature_topic);\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::{\n            ContractsBackend,\n            H256,\n        };\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn emits_foreign_event<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let init_value = false;\n            let mut constructor = EventsRef::new(init_value);\n            let contract = client\n                .instantiate(\"events\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Events>();\n\n            // when\n            let flip = call_builder.flip_with_foreign_event();\n            let flip_res = client\n                .call(&ink_e2e::bob(), &flip)\n                .submit()\n                .await\n                .expect(\"flip failed\");\n\n            let contract_events = flip_res.contract_emitted_events()?;\n\n            // then\n            assert_eq!(1, contract_events.len());\n            let contract_event = &contract_events[0];\n            let flipped: event_def::ForeignFlipped =\n                ink::scale::Decode::decode(&mut &contract_event.event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            assert_eq!(!init_value, flipped.value);\n\n            let signature_topic =\n                <event_def::ForeignFlipped as ink::env::Event>::SIGNATURE_TOPIC\n                    .map(H256::from)\n                    .unwrap();\n\n            let expected_topics = vec![signature_topic];\n            assert_eq!(expected_topics, contract_event.topics);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn emits_inline_event<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let init_value = false;\n            let mut constructor = EventsRef::new(init_value);\n            let contract = client\n                .instantiate(\"events\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Events>();\n\n            // when\n            let flip = call_builder.flip_with_inline_event();\n            let flip_res = client\n                .call(&ink_e2e::bob(), &flip)\n                .submit()\n                .await\n                .expect(\"flip failed\");\n\n            let contract_events = flip_res.contract_emitted_events()?;\n\n            // then\n            assert_eq!(1, contract_events.len());\n            let contract_event = &contract_events[0];\n            let flipped: InlineFlipped =\n                ink::scale::Decode::decode(&mut &contract_event.event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            assert_eq!(!init_value, flipped.value);\n\n            let signature_topic = <InlineFlipped as ink::env::Event>::SIGNATURE_TOPIC\n                .map(H256::from)\n                .unwrap();\n\n            let expected_topics = vec![signature_topic];\n            assert_eq!(expected_topics, contract_event.topics);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn emits_event_with_option_topic_none<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let init_value = false;\n            let mut constructor = EventsRef::new(init_value);\n            let contract = client\n                .instantiate(\"events\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let call_builder = contract.call_builder::<Events>();\n\n            // when\n            let call = call_builder.emit_32_byte_topic_event(None);\n            let call_res = client\n                .call(&ink_e2e::bob(), &call)\n                .submit()\n                .await\n                .expect(\"emit_32_byte_topic_event failed\");\n\n            let contract_events = call_res.contract_emitted_events()?;\n\n            // then\n            assert_eq!(1, contract_events.len());\n            let contract_event = &contract_events[0];\n            let event: event_def::ThirtyTwoByteTopics =\n                ink::scale::Decode::decode(&mut &contract_event.event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            assert!(event.maybe_hash.is_none());\n\n            let signature_topic =\n                <event_def::ThirtyTwoByteTopics as ink::env::Event>::SIGNATURE_TOPIC\n                    .map(H256::from)\n                    .unwrap();\n\n            let expected_topics = vec![\n                signature_topic,\n                [0x42; 32].into(),\n                [0x00; 32].into(), // None is encoded as 0x00\n            ];\n            assert_eq!(expected_topics, contract_event.topics);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn emits_custom_signature_event<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let init_value = false;\n            let mut constructor = EventsRef::new(init_value);\n            let contract = client\n                .instantiate(\"events\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Events>();\n\n            // when\n            let call = call_builder.flip_with_inline_custom_event();\n            let call_res = client\n                .call(&ink_e2e::bob(), &call)\n                .submit()\n                .await\n                .expect(\"flip_with_inline_custom_event failed\");\n\n            let contract_events = call_res.contract_emitted_events()?;\n\n            // then\n            assert_eq!(1, contract_events.len());\n\n            let signature_topic =\n                <InlineCustomFlipped as ink::env::Event>::SIGNATURE_TOPIC;\n\n            assert_eq!(Some([17u8; 32]), signature_topic);\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "flipper",
      "path": "flipper/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Creates a new flipper smart contract initialized with the given value.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Creates a new flipper smart contract initialized to `false`.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Flips the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        fn default_works() {\n            let flipper = Flipper::new_default();\n            assert!(!flipper.get());\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut flipper = Flipper::new(false);\n            assert!(!flipper.get());\n            flipper.flip();\n            assert!(flipper.get());\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn it_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = FlipperRef::new(false);\n            let contract = client\n                .instantiate(\"flipper\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Flipper>();\n\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), false));\n\n            // when\n            let flip = call_builder.flip();\n            let _flip_res = client\n                .call(&ink_e2e::bob(), &flip)\n                .submit()\n                .await\n                .expect(\"flip failed\");\n\n            // then\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), true));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn default_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = FlipperRef::new_default();\n\n            // when\n            let contract = client\n                .instantiate(\"flipper\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let call_builder = contract.call_builder::<Flipper>();\n\n            // then\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), false));\n\n            Ok(())\n        }\n\n        /// This test illustrates how to test an existing on-chain contract.\n        ///\n        /// You can utilize this to e.g. create a snapshot of a production chain\n        /// and run the E2E tests against a deployed contract there.\n        /// This process is explained [here](https://use.ink/5.x/basics/contract-testing/chain-snapshot).\n        ///\n        /// Before executing the test:\n        ///   * Make sure you have a node running in the background,\n        ///   * Supply the environment variable `CONTRACT_HEX` that points to a deployed\n        ///     flipper contract. You can take the SS58 address which `cargo contract\n        ///     instantiate` gives you and convert it to hex using `subkey inspect\n        ///     <SS58>`.\n        ///\n        /// The test is then run like this:\n        ///\n        /// ```\n        /// # The env variable needs to be set, otherwise `ink_e2e` will spawn a new\n        /// # node process for each test.\n        /// $ export CONTRACTS_NODE_URL=ws://127.0.0.1:9944\n        ///\n        /// $ export CONTRACT_ADDR_HEX=0x2c75f0aa09dbfbfd49e6286a0f2edd3b4913f04a58b13391c79e96782f5713e3\n        /// $ cargo test --features e2e-tests e2e_test_deployed_contract -- --ignored\n        /// ```\n        ///\n        /// # Developer Note\n        ///\n        /// The test is marked as ignored, as it has the above pre-conditions to succeed.\n        #[ink_e2e::test]\n        #[ignore]\n        async fn e2e_test_deployed_contract<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let addr = std::env::var(\"CONTRACT_ADDR_HEX\")\n                .unwrap()\n                .replace(\"0x\", \"\");\n            let acc_id = hex::decode(addr).unwrap();\n            let acc_id = AccountId::try_from(&acc_id[..]).unwrap();\n\n            use std::str::FromStr;\n            let suri = ink_e2e::subxt_signer::SecretUri::from_str(\"//Alice\").unwrap();\n            let caller = ink_e2e::Keypair::from_uri(&suri).unwrap();\n\n            // when\n            // Invoke `Flipper::get()` from `caller`'s account\n            let call_builder = ink_e2e::create_call_builder::<Flipper>(acc_id);\n            let get = call_builder.get();\n            let get_res = client.call(&caller, &get).dry_run().await?;\n\n            // then\n            assert_eq!(get_res.return_value(), true);\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "incrementer",
      "path": "incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::incrementer::{\n    Incrementer,\n    IncrementerRef,\n};\n\n#[ink::contract]\nmod incrementer {\n    #[ink(storage)]\n    pub struct Incrementer {\n        value: i32,\n    }\n\n    impl Incrementer {\n        #[ink(constructor)]\n        pub fn new(init_value: i32) -> Self {\n            Self { value: init_value }\n        }\n\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        #[ink(message)]\n        pub fn inc(&mut self, by: i32) {\n            self.value = self.value.checked_add(by).unwrap();\n        }\n\n        #[ink(message)]\n        pub fn get(&self) -> i32 {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        fn default_works() {\n            let contract = Incrementer::new_default();\n            assert_eq!(contract.get(), 0);\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut contract = Incrementer::new(42);\n            assert_eq!(contract.get(), 42);\n            contract.inc(5);\n            assert_eq!(contract.get(), 47);\n            contract.inc(-50);\n            assert_eq!(contract.get(), -3);\n        }\n    }\n}\n"
    },
    {
      "name": "lazyvec",
      "path": "lazyvec/lib.rs",
      "code": "//! A smart contract which demonstrates functionality of `lazyvec` functions.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod lazyvec {\n    use ink::{\n        prelude::vec::Vec,\n        storage::StorageVec,\n    };\n\n    #[cfg_attr(feature = \"std\", derive(ink::storage::traits::StorageLayout))]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub struct Proposal {\n        data: Vec<u8>,\n        until: BlockNumber,\n        approvals: u32,\n        min_approvals: u32,\n    }\n\n    impl Proposal {\n        fn is_finished(&self) -> bool {\n            self.until < ink::env::block_number::<Environment>()\n        }\n    }\n\n    #[ink(storage)]\n    pub struct LazyVector {\n        proposals: StorageVec<Proposal>,\n    }\n\n    impl LazyVector {\n        #[ink(constructor, payable)]\n        pub fn default() -> Self {\n            Self {\n                proposals: Default::default(),\n            }\n        }\n\n        /// Checks whether given account is allowed to vote and didn't already\n        /// participate.\n        fn is_eligible(&self, _voter: AccountId) -> bool {\n            // ToDo: In production, the contract would actually verify eligible voters.\n            // For example, a merkle proof could be an efficient way to do this.\n            true\n        }\n\n        /// Vote to approve the current proposal.\n        #[ink(message)]\n        pub fn approve(&mut self) {\n            assert!(self.is_eligible(self.env().caller()));\n\n            if let Some(mut proposal) = self.proposals.pop() {\n                assert!(!proposal.is_finished());\n\n                proposal.approvals = proposal.approvals.saturating_add(1);\n                self.proposals.push(&proposal);\n            }\n        }\n\n        /// Create a new proposal.\n        ///\n        /// Returns `None` if the current proposal is not yet finished.\n        #[ink(message)]\n        pub fn create_proposal(\n            &mut self,\n            data: Vec<u8>,\n            duration: BlockNumber,\n            min_approvals: u32,\n        ) -> Option<u32> {\n            let proposal_number = match self.proposals.peek() {\n                Some(last) if !last.is_finished() => return None,\n                _ => self.proposals.len(),\n            };\n\n            self.proposals.push(&Proposal {\n                data,\n                until: self.env().block_number().saturating_add(duration.min(6000)),\n                min_approvals,\n                approvals: 0,\n            });\n\n            Some(proposal_number)\n        }\n\n        #[ink(message)]\n        pub fn get(&self, at: u32) -> Option<Proposal> {\n            self.proposals.get(at)\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn create_and_vote<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = LazyVectorRef::default();\n            let contract = client\n                .instantiate(\"lazyvec\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<LazyVector>();\n\n            // when\n            let create = call_builder.create_proposal(vec![0x41], 5, 1);\n            let _ = client\n                .call(&ink_e2e::alice(), &create)\n                .submit()\n                .await\n                .expect(\"Calling `create_proposal` failed\");\n\n            let approve = call_builder.approve();\n            let _ = client\n                .call(&ink_e2e::alice(), &approve)\n                .submit()\n                .await\n                .expect(\"Voting failed\");\n            let _ = client\n                .call(&ink_e2e::bob(), &approve)\n                .submit()\n                .await\n                .expect(\"Voting failed\");\n\n            // then\n            let value = client\n                .call(&ink_e2e::alice(), &create)\n                .dry_run()\n                .await\n                .expect(\"create trapped when it shouldn't\")\n                .return_value();\n            assert_eq!(value, None);\n\n            let value = client\n                .call(&ink_e2e::alice(), &call_builder.get(0))\n                .dry_run()\n                .await\n                .expect(\"get trapped when it shouldn't\")\n                .return_value();\n            assert_eq!(value.unwrap().approvals, 2);\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "mapping",
      "path": "mapping/lib.rs",
      "code": "//! A smart contract which demonstrates functionality of `Mapping` functions.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod mapping {\n    use ink::{\n        prelude::{\n            string::String,\n            vec::Vec,\n        },\n        storage::Mapping,\n    };\n\n    #[derive(Debug, PartialEq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum ContractError {\n        ValueTooLarge,\n    }\n\n    /// A contract for testing `Mapping` functionality.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Mappings {\n        /// Mapping from owner to number of owned token.\n        balances: Mapping<AccountId, Balance>,\n        /// Mapping from owner to aliases.\n        names: Mapping<AccountId, Vec<String>>,\n    }\n\n    impl Mappings {\n        /// Demonstrates the usage of `Mappings::default()`\n        ///\n        /// Creates an empty mapping between accounts and balances.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            let balances = Mapping::default();\n            let names = Mapping::default();\n            Self { balances, names }\n        }\n\n        /// Demonstrates the usage of `Mapping::get()`.\n        ///\n        /// Returns the balance of a account, or `None` if the account is not in the\n        /// `Mapping`.\n        #[ink(message)]\n        pub fn get_balance(&self) -> Option<Balance> {\n            let caller = Self::env().caller();\n            self.balances.get(caller)\n        }\n\n        /// Demonstrates the usage of `Mappings::insert()`.\n        ///\n        /// Assigns the value to a given account.\n        ///\n        /// Returns the size of the pre-existing balance at the specified key if any.\n        /// Returns `None` if the account was not previously in the `Mapping`.\n        #[ink(message)]\n        pub fn insert_balance(&mut self, value: Balance) -> Option<u32> {\n            let caller = Self::env().caller();\n            self.balances.insert(caller, &value)\n        }\n\n        /// Demonstrates the usage of `Mappings::size()`.\n        ///\n        /// Returns the size of the pre-existing balance at the specified key if any.\n        /// Returns `None` if the account was not previously in the `Mapping`.\n        #[ink(message)]\n        pub fn size_balance(&mut self) -> Option<u32> {\n            let caller = Self::env().caller();\n            self.balances.size(caller)\n        }\n\n        /// Demonstrates the usage of `Mapping::contains()`.\n        ///\n        /// Returns `true` if the account has any balance assigned to it.\n        #[ink(message)]\n        pub fn contains_balance(&self) -> bool {\n            let caller = Self::env().caller();\n            self.balances.contains(caller)\n        }\n\n        /// Demonstrates the usage of `Mappings::remove()`.\n        ///\n        /// Removes the balance entry for a given account.\n        #[ink(message)]\n        pub fn remove_balance(&mut self) {\n            let caller = Self::env().caller();\n            self.balances.remove(caller);\n        }\n\n        /// Demonstrates the usage of `Mappings::take()`.\n        ///\n        /// Returns the balance of a given account removing it from storage.\n        ///\n        /// Returns `None` if the account is not in the `Mapping`.\n        #[ink(message)]\n        pub fn take_balance(&mut self) -> Option<Balance> {\n            let caller = Self::env().caller();\n            self.balances.take(caller)\n        }\n\n        /// Demonstrates the usage of `Mappings::try_take()` and `Mappings::try_insert()`.\n        ///\n        /// Adds a name of a given account.\n        ///\n        /// Returns `Ok(None)` if the account is not in the `Mapping`.\n        /// Returns `Ok(Some(_))` if the account was already in the `Mapping`\n        /// Returns `Err(_)` if the mapping value couldn't be encoded.\n        #[ink(message)]\n        pub fn try_insert_name(&mut self, name: String) -> Result<(), ContractError> {\n            let caller = Self::env().caller();\n            let mut names = match self.names.try_take(caller) {\n                None => Vec::new(),\n                Some(value) => value.map_err(|_| ContractError::ValueTooLarge)?,\n            };\n\n            names.push(name);\n\n            self.names\n                .try_insert(caller, &names)\n                .map_err(|_| ContractError::ValueTooLarge)?;\n\n            Ok(())\n        }\n\n        /// Demonstrates the usage of `Mappings::try_get()`.\n        ///\n        /// Returns the name of a given account.\n        ///\n        /// Returns `Ok(None)` if the account is not in the `Mapping`.\n        /// Returns `Ok(Some(_))` if the account was already in the `Mapping`\n        /// Returns `Err(_)` if the mapping value couldn't be encoded.\n        #[ink(message)]\n        pub fn try_get_names(&mut self) -> Option<Result<Vec<String>, ContractError>> {\n            let caller = Self::env().caller();\n            self.names\n                .try_get(caller)\n                .map(|result| result.map_err(|_| ContractError::ValueTooLarge))\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn insert_and_get_works<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when\n            let insert = call_builder.insert_balance(1_000);\n            let size = client\n                .call(&ink_e2e::alice(), &insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            // then\n            let get = call_builder.get_balance();\n            let balance = client\n                .call(&ink_e2e::alice(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n\n            assert!(size.is_none());\n            assert_eq!(balance, Some(1_000));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn insert_and_contains_works<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when\n            let insert = call_builder.insert_balance(1_000);\n            let _ = client\n                .call(&ink_e2e::bob(), &insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            // then\n            let contains = call_builder.contains_balance();\n            let is_there = client\n                .call(&ink_e2e::bob(), &contains)\n                .dry_run()\n                .await?\n                .return_value();\n\n            assert!(is_there);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn reinsert_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::charlie(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when\n            let first_insert = call_builder.insert_balance(1_000);\n            let _ = client\n                .call(&ink_e2e::charlie(), &first_insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            let insert = call_builder.insert_balance(10_000);\n            let size = client\n                .call(&ink_e2e::charlie(), &insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            // then\n            assert!(size.is_some());\n\n            let get = call_builder.get_balance();\n            let balance = client\n                .call(&ink_e2e::charlie(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n\n            assert_eq!(balance, Some(10_000));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn insert_and_remove_works<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::dave(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when\n            let insert = call_builder.insert_balance(3_000);\n            let _ = client\n                .call(&ink_e2e::dave(), &insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            let remove = call_builder.remove_balance();\n            let _ = client\n                .call(&ink_e2e::dave(), &remove)\n                .submit()\n                .await\n                .expect(\"Calling `remove_balance` failed\");\n\n            // then\n            let get = call_builder.get_balance();\n            let balance = client\n                .call(&ink_e2e::dave(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n\n            assert_eq!(balance, None);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn insert_and_take_works<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::eve(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when\n            let insert = call_builder.insert_balance(4_000);\n            let _ = client\n                .call(&ink_e2e::eve(), &insert)\n                .submit()\n                .await\n                .expect(\"Calling `insert_balance` failed\")\n                .return_value();\n\n            let take = call_builder.take_balance();\n            let balance = client\n                .call(&ink_e2e::eve(), &take)\n                .submit()\n                .await\n                .expect(\"Calling `take_balance` failed\")\n                .return_value();\n\n            // then\n            assert_eq!(balance, Some(4_000));\n\n            let contains = call_builder.contains_balance();\n            let is_there = client\n                .call(&ink_e2e::eve(), &contains)\n                .dry_run()\n                .await?\n                .return_value();\n\n            assert!(!is_there);\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn fallible_storage_methods_work<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = MappingsRef::new();\n            let contract = client\n                .instantiate(\"mapping\", &ink_e2e::ferdie(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Mappings>();\n\n            // when the mapping value overgrows the buffer\n            let name = ink_e2e::ferdie().public_key().to_account_id().to_string();\n            let insert = call_builder.try_insert_name(name.clone());\n            let mut names = Vec::new();\n            while let Ok(_) = client.call(&ink_e2e::ferdie(), &insert).submit().await {\n                names.push(name.clone())\n            }\n\n            // then adding another one should fail gracefully\n            let expected_insert_result = client\n                .call(&ink_e2e::ferdie(), &insert)\n                .dry_run()\n                .await?\n                .return_value();\n            let received_insert_result =\n                Err(crate::mapping::ContractError::ValueTooLarge);\n            assert_eq!(received_insert_result, expected_insert_result);\n\n            // then there should be 4 entries (that's what fits into the 256kb buffer)\n            let received_mapping_value = client\n                .call(&ink_e2e::ferdie(), &call_builder.try_get_names())\n                .dry_run()\n                .await?\n                .return_value();\n            let expected_mapping_value = Some(Ok(names));\n            assert_eq!(received_mapping_value, expected_mapping_value);\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "accumulator",
      "path": "multi-contract-caller/accumulator/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::accumulator::{\n    Accumulator,\n    AccumulatorRef,\n};\n\n#[ink::contract]\npub mod accumulator {\n    /// Holds a simple `i32` value that can be incremented and decremented.\n    #[ink(storage)]\n    pub struct Accumulator {\n        value: i32,\n    }\n\n    impl Accumulator {\n        /// Initializes the value to the initial value.\n        #[ink(constructor, payable)]\n        pub fn new(init_value: i32) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Mutates the internal value.\n        #[ink(message)]\n        pub fn inc(&mut self, by: i32) {\n            self.value = self.value.checked_add(by).unwrap();\n        }\n\n        /// Returns the current state.\n        #[ink(message)]\n        pub fn get(&self) -> i32 {\n            self.value\n        }\n    }\n}\n"
    },
    {
      "name": "adder",
      "path": "multi-contract-caller/adder/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::adder::{\n    Adder,\n    AdderRef,\n};\n\n#[ink::contract]\nmod adder {\n    use accumulator::AccumulatorRef;\n\n    /// Increments the underlying `accumulator` value.\n    #[ink(storage)]\n    pub struct Adder {\n        /// The `accumulator` to store the value.\n        accumulator: AccumulatorRef,\n    }\n\n    impl Adder {\n        /// Creates a new `adder` from the given `accumulator`.\n        #[ink(constructor, payable)]\n        pub fn new(accumulator: AccumulatorRef) -> Self {\n            Self { accumulator }\n        }\n\n        /// Increases the `accumulator` value by some amount.\n        #[ink(message)]\n        pub fn inc(&mut self, by: i32) {\n            self.accumulator.inc(by)\n        }\n    }\n}\n"
    },
    {
      "name": "multi-contract-caller",
      "path": "multi-contract-caller/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod multi_contract_caller {\n    use accumulator::AccumulatorRef;\n    use adder::AdderRef;\n    use subber::SubberRef;\n\n    /// Specifies the state of the `multi_contract_caller` contract.\n    ///\n    /// In `Adder` state the `multi_contract_caller` contract will call the `Adder`\n    /// contract and in `Subber` state will call to the `Subber` contract.\n    ///\n    /// The initial state is `Adder`.\n    #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n    #[cfg_attr(feature = \"std\", derive(ink::storage::traits::StorageLayout))]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Which {\n        Adder,\n        Subber,\n    }\n\n    /// Calls to an `adder` or `subber` contract to mutate a value in an `accumulator`\n    /// contract.\n    ///\n    /// # Note\n    ///\n    /// In order to instantiate the `multi_contract_caller` smart contract we first\n    /// have to manually put the code of the `accumulator`, `adder`\n    /// and `subber` smart contracts, receive their code hashes from\n    /// the signalled events and put their code hash into our\n    /// `multi_contract_caller` smart contract.\n    ///\n    /// The `AccumulatorRef`, `AdderRef` and `SubberRef` are smart contract\n    /// reference types that have been automatically generated by ink!.\n    #[ink(storage)]\n    pub struct MultiContractCaller {\n        /// Says which of `adder` or `subber` is currently in use.\n        which: Which,\n        /// The `accumulator` smart contract.\n        accumulator: AccumulatorRef,\n        /// The `adder` smart contract.\n        adder: AdderRef,\n        /// The `subber` smart contract.\n        subber: SubberRef,\n    }\n\n    impl MultiContractCaller {\n        /// Instantiate a `multi_contract_caller` contract with the given sub-contract\n        /// codes.\n        #[ink(constructor, payable)]\n        pub fn new(\n            init_value: i32,\n            version: u32,\n            accumulator_code_hash: Hash,\n            adder_code_hash: Hash,\n            subber_code_hash: Hash,\n        ) -> Self {\n            let total_balance = Self::env().balance();\n            let salt = version.to_le_bytes();\n            let accumulator = AccumulatorRef::new(init_value)\n                .endowment(total_balance / 4)\n                .code_hash(accumulator_code_hash)\n                .salt_bytes(salt)\n                .instantiate();\n            let adder = AdderRef::new(accumulator.clone())\n                .endowment(total_balance / 4)\n                .code_hash(adder_code_hash)\n                .salt_bytes(salt)\n                .instantiate();\n            let subber = SubberRef::new(accumulator.clone())\n                .endowment(total_balance / 4)\n                .code_hash(subber_code_hash)\n                .salt_bytes(salt)\n                .instantiate();\n            Self {\n                which: Which::Adder,\n                accumulator,\n                adder,\n                subber,\n            }\n        }\n\n        /// Returns the `accumulator` value.\n        #[ink(message)]\n        pub fn get(&self) -> i32 {\n            self.accumulator.get()\n        }\n\n        /// Delegates the call to either `Adder` or `Subber`.\n        #[ink(message)]\n        pub fn change(&mut self, by: i32) {\n            match self.which {\n                Which::Adder => self.adder.inc(by),\n                Which::Subber => self.subber.dec(by),\n            }\n        }\n\n        /// Switches the `multi_contract_caller` contract.\n        #[ink(message)]\n        pub fn switch(&mut self) {\n            match self.which {\n                Which::Adder => {\n                    self.which = Which::Subber;\n                }\n                Which::Subber => {\n                    self.which = Which::Adder;\n                }\n            }\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn e2e_multi_contract_caller<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let accumulator_hash = client\n                .upload(\"accumulator\", &ink_e2e::alice())\n                .submit()\n                .await\n                .expect(\"uploading `accumulator` failed\")\n                .code_hash;\n\n            let adder_hash = client\n                .upload(\"adder\", &ink_e2e::alice())\n                .submit()\n                .await\n                .expect(\"uploading `adder` failed\")\n                .code_hash;\n\n            let subber_hash = client\n                .upload(\"subber\", &ink_e2e::alice())\n                .submit()\n                .await\n                .expect(\"uploading `subber` failed\")\n                .code_hash;\n\n            let mut constructor = MultiContractCallerRef::new(\n                1234, // initial value\n                1337, // salt\n                accumulator_hash,\n                adder_hash,\n                subber_hash,\n            );\n\n            let multi_contract_caller = client\n                .instantiate(\"multi_contract_caller\", &ink_e2e::alice(), &mut constructor)\n                .value(10_000_000_000_000)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder =\n                multi_contract_caller.call_builder::<MultiContractCaller>();\n\n            // when\n            let get = call_builder.get();\n            let value = client\n                .call(&ink_e2e::bob(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n            assert_eq!(value, 1234);\n            let change = call_builder.change(6);\n            let _ = client\n                .call(&ink_e2e::bob(), &change)\n                .submit()\n                .await\n                .expect(\"calling `change` failed\");\n\n            // then\n            let get = call_builder.get();\n            let value = client\n                .call(&ink_e2e::bob(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n            assert_eq!(value, 1234 + 6);\n\n            // when\n            let switch = call_builder.switch();\n            let _ = client\n                .call(&ink_e2e::bob(), &switch)\n                .submit()\n                .await\n                .expect(\"calling `switch` failed\");\n            let change = call_builder.change(3);\n            let _ = client\n                .call(&ink_e2e::bob(), &change)\n                .submit()\n                .await\n                .expect(\"calling `change` failed\");\n\n            // then\n            let get = call_builder.get();\n            let value = client\n                .call(&ink_e2e::bob(), &get)\n                .dry_run()\n                .await?\n                .return_value();\n            assert_eq!(value, 1234 + 6 - 3);\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "subber",
      "path": "multi-contract-caller/subber/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::subber::{\n    Subber,\n    SubberRef,\n};\n\n#[ink::contract]\nmod subber {\n    use accumulator::AccumulatorRef;\n\n    /// Decreases the underlying `accumulator` value.\n    #[ink(storage)]\n    pub struct Subber {\n        /// The `accumulator` to store the value.\n        accumulator: AccumulatorRef,\n    }\n\n    impl Subber {\n        /// Creates a new `subber` from the given `accumulator`.\n        #[ink(constructor, payable)]\n        pub fn new(accumulator: AccumulatorRef) -> Self {\n            Self { accumulator }\n        }\n\n        /// Decreases the `accumulator` value by some amount.\n        #[ink(message)]\n        pub fn dec(&mut self, by: i32) {\n            self.accumulator.inc(0i32.checked_sub(by).unwrap())\n        }\n    }\n}\n"
    },
    {
      "name": "multisig",
      "path": "multisig/lib.rs",
      "code": "//! # Multisig Wallet\n//!\n//! This implements a plain multi owner wallet.\n//!\n//! ## Warning\n//!\n//! This contract is an *example*. It is neither audited nor endorsed for production use.\n//! Do **not** rely on it to keep anything of value secure.\n//!\n//! ## Overview\n//!\n//! Each instantiation of this contract has a set of `owners` and a `requirement` of\n//! how many of them need to agree on a `Transaction` for it to be able to be executed.\n//! Every owner can submit a transaction and when enough of the other owners confirm\n//! it will be able to be executed. The following invariant is enforced by the contract:\n//!\n//! ```ignore\n//! 0 < requirement && requirement <= owners && owners <= MAX_OWNERS\n//! ```\n//!\n//! ## Error Handling\n//!\n//! With the exception of `execute_transaction` no error conditions are signalled\n//! through return types. Any error or invariant violation triggers a panic and therefore\n//! rolls back the transaction.\n//!\n//! ## Interface\n//!\n//! The interface is modelled after the popular Gnosis multisig wallet. However, there\n//! are subtle variations from the interface. For example the `confirm_transaction`\n//! will never trigger the execution of a `Transaction` even if the threshold is reached.\n//! A call of `execute_transaction` is always required. This can be called by anyone.\n//!\n//! All the messages that are declared as only callable by the wallet must go through\n//! the usual submit, confirm, execute cycle as any other transaction that should be\n//! called by the wallet. For example, to add an owner you would submit a transaction\n//! that calls the wallets own `add_owner` message through `submit_transaction`.\n//!\n//! ### Owner Management\n//!\n//! The messages `add_owner`, `remove_owner`, and `replace_owner` can be used to manage\n//! the owner set after instantiation.\n//!\n//! ### Changing the Requirement\n//!\n//! `change_requirement` can be used to tighten or relax the `requirement` of how many\n//! owner signatures are needed to execute a `Transaction`.\n//!\n//! ### Transaction Management\n//!\n//! `submit_transaction`, `cancel_transaction`, `confirm_transaction`,\n//! `revoke_confirmation` and `execute_transaction` are the bread and butter messages\n//! of this contract. Use them to dispatch arbitrary messages to other contracts\n//! with the wallet as a sender.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::multisig::{\n    ConfirmationStatus,\n    Multisig,\n    Transaction,\n};\n\n#[ink::contract]\nmod multisig {\n    use ink::{\n        env::{\n            call::{\n                build_call,\n                ExecutionInput,\n            },\n            CallFlags,\n        },\n        prelude::vec::Vec,\n        scale::Output,\n        storage::Mapping,\n    };\n\n    /// Tune this to your liking but be wary that allowing too many owners will not\n    /// perform well.\n    const MAX_OWNERS: u32 = 50;\n\n    type TransactionId = u32;\n    const WRONG_TRANSACTION_ID: &str =\n        \"The user specified an invalid transaction id. Abort.\";\n\n    /// A wrapper that allows us to encode a blob of bytes.\n    ///\n    /// We use this to pass the set of untyped (bytes) parameters to the `CallBuilder`.\n    #[derive(Clone)]\n    struct CallInput<'a>(&'a [u8]);\n\n    impl<'a> ink::scale::Encode for CallInput<'a> {\n        fn encode_to<T: Output + ?Sized>(&self, dest: &mut T) {\n            dest.write(self.0);\n        }\n    }\n\n    /// Indicates whether a transaction is already confirmed or needs further\n    /// confirmations.\n    #[derive(Clone, Copy)]\n    #[cfg_attr(feature = \"std\", derive(ink::storage::traits::StorageLayout))]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum ConfirmationStatus {\n        /// The transaction is already confirmed.\n        Confirmed,\n        /// Indicates how many confirmations are remaining.\n        ConfirmationsNeeded(u32),\n    }\n\n    /// A Transaction is what every `owner` can submit for confirmation by other owners.\n    /// If enough owners agree it will be executed by the contract.\n    #[derive(Clone)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(Debug, PartialEq, Eq, ink::storage::traits::StorageLayout)\n    )]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub struct Transaction {\n        /// The `AccountId` of the contract that is called in this transaction.\n        pub callee: AccountId,\n        /// The selector bytes that identifies the function of the callee that should be\n        /// called.\n        pub selector: [u8; 4],\n        /// The SCALE encoded parameters that are passed to the called function.\n        pub input: Vec<u8>,\n        /// The amount of chain balance that is transferred to the callee.\n        pub transferred_value: Balance,\n        /// Gas limit for the execution of the call.\n        pub ref_time_limit: u64,\n        /// If set to true the transaction will be allowed to re-enter the multisig\n        /// contract. Re-entrancy can lead to vulnerabilities. Use at your own\n        /// risk.\n        pub allow_reentry: bool,\n    }\n\n    /// Errors that can occur upon calling this contract.\n    #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if the call failed.\n        TransactionFailed,\n    }\n\n    /// This is a book keeping struct that stores a list of all transaction ids and\n    /// also the next id to use. We need it for cleaning up the storage.\n    #[derive(Clone, Default)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(Debug, PartialEq, Eq, ink::storage::traits::StorageLayout)\n    )]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub struct Transactions {\n        /// Just store all transaction ids packed.\n        transactions: Vec<TransactionId>,\n        /// We just increment this whenever a new transaction is created.\n        /// We never decrement or defragment. For now, the contract becomes defunct\n        /// when the ids are exhausted.\n        next_id: TransactionId,\n    }\n\n    /// Emitted when an owner confirms a transaction.\n    #[ink(event)]\n    pub struct Confirmation {\n        /// The transaction that was confirmed.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// The owner that sent the confirmation.\n        #[ink(topic)]\n        from: AccountId,\n        /// The confirmation status after this confirmation was applied.\n        #[ink(topic)]\n        status: ConfirmationStatus,\n    }\n\n    /// Emitted when an owner revoked a confirmation.\n    #[ink(event)]\n    pub struct Revocation {\n        /// The transaction that was revoked.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// The owner that sent the revocation.\n        #[ink(topic)]\n        from: AccountId,\n    }\n\n    /// Emitted when an owner submits a transaction.\n    #[ink(event)]\n    pub struct Submission {\n        /// The transaction that was submitted.\n        #[ink(topic)]\n        transaction: TransactionId,\n    }\n\n    /// Emitted when a transaction was canceled.\n    #[ink(event)]\n    pub struct Cancellation {\n        /// The transaction that was canceled.\n        #[ink(topic)]\n        transaction: TransactionId,\n    }\n\n    /// Emitted when a transaction was executed.\n    #[ink(event)]\n    pub struct Execution {\n        /// The transaction that was executed.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// Indicates whether the transaction executed successfully. If so the `Ok` value\n        /// holds the output in bytes. The Option is `None` when the transaction\n        /// was executed through `invoke_transaction` rather than\n        /// `evaluate_transaction`.\n        #[ink(topic)]\n        result: Result<Option<Vec<u8>>, Error>,\n    }\n\n    /// Emitted when an owner is added to the wallet.\n    #[ink(event)]\n    pub struct OwnerAddition {\n        /// The owner that was added.\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    /// Emitted when an owner is removed from the wallet.\n    #[ink(event)]\n    pub struct OwnerRemoval {\n        /// The owner that was removed.\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    /// Emitted when the requirement changed.\n    #[ink(event)]\n    pub struct RequirementChange {\n        /// The new requirement value.\n        new_requirement: u32,\n    }\n\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Multisig {\n        /// Every entry in this map represents the confirmation of an owner for a\n        /// transaction. This is effectively a set rather than a map.\n        confirmations: Mapping<(TransactionId, AccountId), ()>,\n        /// The amount of confirmations for every transaction. This is a redundant\n        /// information and is kept in order to prevent iterating through the\n        /// confirmation set to check if a transaction is confirmed.\n        confirmation_count: Mapping<TransactionId, u32>,\n        /// Map the transaction id to its not-executed transaction.\n        transactions: Mapping<TransactionId, Transaction>,\n        /// We need to hold a list of all transactions so that we can clean up storage\n        /// when an owner is removed.\n        transaction_list: Transactions,\n        /// The list is a vector because iterating over it is necessary when cleaning\n        /// up the confirmation set.\n        owners: Vec<AccountId>,\n        /// Redundant information to speed up the check whether a caller is an owner.\n        is_owner: Mapping<AccountId, ()>,\n        /// Minimum number of owners that have to confirm a transaction to be executed.\n        requirement: u32,\n    }\n\n    impl Multisig {\n        /// The only constructor of the contract.\n        ///\n        /// A list of owners must be supplied and a number of how many of them must\n        /// confirm a transaction. Duplicate owners are silently dropped.\n        ///\n        /// # Panics\n        ///\n        /// If `requirement` violates our invariant.\n        #[ink(constructor)]\n        pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {\n            let mut contract = Multisig::default();\n            owners.sort_unstable();\n            owners.dedup();\n            ensure_requirement_is_valid(owners.len() as u32, requirement);\n\n            for owner in &owners {\n                contract.is_owner.insert(owner, &());\n            }\n\n            contract.owners = owners;\n            contract.transaction_list = Default::default();\n            contract.requirement = requirement;\n            contract\n        }\n\n        /// Add a new owner to the contract.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If the owner already exists.\n        ///\n        /// # Examples\n        ///\n        /// Since this message must be send by the wallet itself it has to be build as a\n        /// `Transaction` and dispatched through `submit_transaction` and\n        /// `invoke_transaction`:\n        /// ```should_panic\n        /// use ink::{\n        ///     env::{\n        ///         call::{\n        ///             utils::ArgumentList,\n        ///             Call,\n        ///             CallParams,\n        ///             ExecutionInput,\n        ///             Selector,\n        ///         },\n        ///         DefaultEnvironment as Env,\n        ///         Environment,\n        ///     },\n        ///     scale::Encode,\n        ///     selector_bytes,\n        /// };\n        /// use multisig::{\n        ///     ConfirmationStatus,\n        ///     Transaction,\n        /// };\n        ///\n        /// type AccountId = <Env as Environment>::AccountId;\n        ///\n        /// // address of an existing `Multisig` contract\n        /// let wallet_id: AccountId = [7u8; 32].into();\n        ///\n        /// // first create the transaction that adds `alice` through `add_owner`\n        /// let alice: AccountId = [1u8; 32].into();\n        /// let add_owner_args = ArgumentList::empty().push_arg(&alice);\n        ///\n        /// let transaction_candidate = Transaction {\n        ///     callee: wallet_id,\n        ///     selector: selector_bytes!(\"add_owner\"),\n        ///     input: add_owner_args.encode(),\n        ///     transferred_value: 0,\n        ///     ref_time_limit: 0,\n        ///     allow_reentry: true,\n        /// };\n        ///\n        /// // Submit the transaction for confirmation\n        /// //\n        /// // Note that the selector bytes of the `submit_transaction` method\n        /// // are `[86, 244, 13, 223]`.\n        /// let (id, _status) = ink::env::call::build_call::<Env>()\n        ///     .call_type(Call::new(wallet_id))\n        ///     .ref_time_limit(0)\n        ///     .exec_input(\n        ///         ExecutionInput::new(Selector::new([86, 244, 13, 223]))\n        ///             .push_arg(&transaction_candidate),\n        ///     )\n        ///     .returns::<(u32, ConfirmationStatus)>()\n        ///     .invoke();\n        ///\n        /// // Wait until all owners have confirmed and then execute the tx.\n        /// //\n        /// // Note that the selector bytes of the `invoke_transaction` method\n        /// // are `[185, 50, 225, 236]`.\n        /// ink::env::call::build_call::<Env>()\n        ///     .call_type(Call::new(wallet_id))\n        ///     .ref_time_limit(0)\n        ///     .exec_input(ExecutionInput::new(Selector::new([185, 50, 225, 236])).push_arg(&id))\n        ///     .returns::<()>()\n        ///     .invoke();\n        /// ```\n        #[ink(message)]\n        pub fn add_owner(&mut self, new_owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_no_owner(&new_owner);\n            ensure_requirement_is_valid(\n                (self.owners.len() as u32).checked_add(1).unwrap(),\n                self.requirement,\n            );\n            self.is_owner.insert(new_owner, &());\n            self.owners.push(new_owner);\n            self.env().emit_event(OwnerAddition { owner: new_owner });\n        }\n\n        /// Remove an owner from the contract.\n        ///\n        /// Only callable by the wallet itself. If by doing this the amount of owners\n        /// would be smaller than the requirement it is adjusted to be exactly the\n        /// number of owners.\n        ///\n        /// # Panics\n        ///\n        /// If `owner` is no owner of the wallet.\n        #[ink(message)]\n        pub fn remove_owner(&mut self, owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_owner(&owner);\n            // If caller is an owner the len has to be > 0\n            #[allow(clippy::arithmetic_side_effects)]\n            let len = self.owners.len() as u32 - 1;\n            let requirement = u32::min(len, self.requirement);\n            ensure_requirement_is_valid(len, requirement);\n            let owner_index = self.owner_index(&owner) as usize;\n            self.owners.swap_remove(owner_index);\n            self.is_owner.remove(owner);\n            self.requirement = requirement;\n            self.clean_owner_confirmations(&owner);\n            self.env().emit_event(OwnerRemoval { owner });\n        }\n\n        /// Replace an owner from the contract with a new one.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If `old_owner` is no owner or if `new_owner` already is one.\n        #[ink(message)]\n        pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_owner(&old_owner);\n            self.ensure_no_owner(&new_owner);\n            let owner_index = self.owner_index(&old_owner);\n            self.owners[owner_index as usize] = new_owner;\n            self.is_owner.remove(old_owner);\n            self.is_owner.insert(new_owner, &());\n            self.clean_owner_confirmations(&old_owner);\n            self.env().emit_event(OwnerRemoval { owner: old_owner });\n            self.env().emit_event(OwnerAddition { owner: new_owner });\n        }\n\n        /// Change the requirement to a new value.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If the `new_requirement` violates our invariant.\n        #[ink(message)]\n        pub fn change_requirement(&mut self, new_requirement: u32) {\n            self.ensure_from_wallet();\n            ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);\n            self.requirement = new_requirement;\n            self.env().emit_event(RequirementChange { new_requirement });\n        }\n\n        /// Add a new transaction candidate to the contract.\n        ///\n        /// This also confirms the transaction for the caller. This can be called by any\n        /// owner.\n        #[ink(message)]\n        pub fn submit_transaction(\n            &mut self,\n            transaction: Transaction,\n        ) -> (TransactionId, ConfirmationStatus) {\n            self.ensure_caller_is_owner();\n            let trans_id = self.transaction_list.next_id;\n            self.transaction_list.next_id =\n                trans_id.checked_add(1).expect(\"Transaction ids exhausted.\");\n            self.transactions.insert(trans_id, &transaction);\n            self.transaction_list.transactions.push(trans_id);\n            self.env().emit_event(Submission {\n                transaction: trans_id,\n            });\n            (\n                trans_id,\n                self.confirm_by_caller(self.env().caller(), trans_id),\n            )\n        }\n\n        /// Remove a transaction from the contract.\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn cancel_transaction(&mut self, trans_id: TransactionId) {\n            self.ensure_from_wallet();\n            if self.take_transaction(trans_id).is_some() {\n                self.env().emit_event(Cancellation {\n                    transaction: trans_id,\n                });\n            }\n        }\n\n        /// Confirm a transaction for the sender that was submitted by any owner.\n        ///\n        /// This can be called by any owner.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn confirm_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> ConfirmationStatus {\n            self.ensure_caller_is_owner();\n            self.ensure_transaction_exists(trans_id);\n            self.confirm_by_caller(self.env().caller(), trans_id)\n        }\n\n        /// Revoke the senders confirmation.\n        ///\n        /// This can be called by any owner.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {\n            self.ensure_caller_is_owner();\n            let caller = self.env().caller();\n            if self.confirmations.contains((trans_id, caller)) {\n                self.confirmations.remove((trans_id, caller));\n                let mut confirmation_count = self\n                    .confirmation_count\n                    .get(trans_id)\n                    .expect(\n                    \"There is a entry in `self.confirmations`. Hence a count must exit.\",\n                );\n                // Will not underflow as there is at least one confirmation\n                #[allow(clippy::arithmetic_side_effects)]\n                {\n                    confirmation_count -= 1;\n                }\n                self.confirmation_count\n                    .insert(trans_id, &confirmation_count);\n                self.env().emit_event(Revocation {\n                    transaction: trans_id,\n                    from: caller,\n                });\n            }\n        }\n\n        /// Invoke a confirmed execution without getting its output.\n        ///\n        /// If the transaction which is invoked transfers value, this value has\n        /// to be sent as payment with this call. The method will fail otherwise,\n        /// and the transaction would then be reverted.\n        ///\n        /// Its return value indicates whether the called transaction was successful.\n        /// This can be called by anyone.\n        #[ink(message, payable)]\n        pub fn invoke_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> Result<(), Error> {\n            self.ensure_confirmed(trans_id);\n            let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);\n            assert!(self.env().transferred_value() == t.transferred_value);\n            let call_flags = if t.allow_reentry {\n                CallFlags::ALLOW_REENTRY\n            } else {\n                CallFlags::empty()\n            };\n\n            let result = build_call::<<Self as ::ink::env::ContractEnv>::Env>()\n                .call(t.callee)\n                .ref_time_limit(t.ref_time_limit)\n                .transferred_value(t.transferred_value)\n                .call_flags(call_flags)\n                .exec_input(\n                    ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)),\n                )\n                .returns::<()>()\n                .try_invoke();\n\n            let result = match result {\n                Ok(Ok(_)) => Ok(()),\n                _ => Err(Error::TransactionFailed),\n            };\n\n            self.env().emit_event(Execution {\n                transaction: trans_id,\n                result: result.map(|_| None),\n            });\n            result\n        }\n\n        /// Evaluate a confirmed execution and return its output as bytes.\n        ///\n        /// Its return value indicates whether the called transaction was successful and\n        /// contains its output when successful.\n        /// This can be called by anyone.\n        #[ink(message, payable)]\n        pub fn eval_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> Result<Vec<u8>, Error> {\n            self.ensure_confirmed(trans_id);\n            let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);\n            let call_flags = if t.allow_reentry {\n                CallFlags::ALLOW_REENTRY\n            } else {\n                CallFlags::empty()\n            };\n\n            let result = build_call::<<Self as ::ink::env::ContractEnv>::Env>()\n                .call(t.callee)\n                .ref_time_limit(t.ref_time_limit)\n                .transferred_value(t.transferred_value)\n                .call_flags(call_flags)\n                .exec_input(\n                    ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)),\n                )\n                .returns::<Vec<u8>>()\n                .try_invoke();\n\n            let result = match result {\n                Ok(Ok(v)) => Ok(v),\n                _ => Err(Error::TransactionFailed),\n            };\n\n            self.env().emit_event(Execution {\n                transaction: trans_id,\n                result: result.clone().map(Some),\n            });\n            result\n        }\n\n        /// Set the `transaction` as confirmed by `confirmer`.\n        /// Idempotent operation regarding an already confirmed `transaction`\n        /// by `confirmer`.\n        fn confirm_by_caller(\n            &mut self,\n            confirmer: AccountId,\n            transaction: TransactionId,\n        ) -> ConfirmationStatus {\n            let mut count = self.confirmation_count.get(transaction).unwrap_or(0);\n            let key = (transaction, confirmer);\n            let new_confirmation = !self.confirmations.contains(key);\n            if new_confirmation {\n                count = count.checked_add(1).unwrap();\n                self.confirmations.insert(key, &());\n                self.confirmation_count.insert(transaction, &count);\n            }\n            let status = {\n                if count >= self.requirement {\n                    ConfirmationStatus::Confirmed\n                } else {\n                    // We checked that count < self.requirement\n                    #[allow(clippy::arithmetic_side_effects)]\n                    ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)\n                }\n            };\n            if new_confirmation {\n                self.env().emit_event(Confirmation {\n                    transaction,\n                    from: confirmer,\n                    status,\n                });\n            }\n            status\n        }\n\n        /// Get the index of `owner` in `self.owners`.\n        /// Panics if `owner` is not found in `self.owners`.\n        fn owner_index(&self, owner: &AccountId) -> u32 {\n            self.owners.iter().position(|x| *x == *owner).expect(\n                \"This is only called after it was already verified that the id is\n                 actually an owner.\",\n            ) as u32\n        }\n\n        /// Remove the transaction identified by `trans_id` from `self.transactions`.\n        /// Also removes all confirmation state associated with it.\n        fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {\n            let transaction = self.transactions.get(trans_id);\n            if transaction.is_some() {\n                self.transactions.remove(trans_id);\n                let pos = self\n                    .transaction_list\n                    .transactions\n                    .iter()\n                    .position(|t| t == &trans_id)\n                    .expect(\"The transaction exists hence it must also be in the list.\");\n                self.transaction_list.transactions.swap_remove(pos);\n                for owner in self.owners.iter() {\n                    self.confirmations.remove((trans_id, *owner));\n                }\n                self.confirmation_count.remove(trans_id);\n            }\n            transaction\n        }\n\n        /// Remove all confirmation state associated with `owner`.\n        /// Also adjusts the `self.confirmation_count` variable.\n        fn clean_owner_confirmations(&mut self, owner: &AccountId) {\n            for trans_id in &self.transaction_list.transactions {\n                let key = (*trans_id, *owner);\n                if self.confirmations.contains(key) {\n                    self.confirmations.remove(key);\n                    let mut count = self.confirmation_count.get(trans_id).unwrap_or(0);\n                    count = count.saturating_sub(1);\n                    self.confirmation_count.insert(trans_id, &count);\n                }\n            }\n        }\n\n        /// Panic if transaction `trans_id` is not confirmed by at least\n        /// `self.requirement` owners.\n        fn ensure_confirmed(&self, trans_id: TransactionId) {\n            assert!(\n                self.confirmation_count\n                    .get(trans_id)\n                    .expect(WRONG_TRANSACTION_ID)\n                    >= self.requirement\n            );\n        }\n\n        /// Panic if the transaction `trans_id` does not exit.\n        fn ensure_transaction_exists(&self, trans_id: TransactionId) {\n            self.transactions.get(trans_id).expect(WRONG_TRANSACTION_ID);\n        }\n\n        /// Panic if the sender is no owner of the wallet.\n        fn ensure_caller_is_owner(&self) {\n            self.ensure_owner(&self.env().caller());\n        }\n\n        /// Panic if the sender is not this wallet.\n        fn ensure_from_wallet(&self) {\n            assert_eq!(self.env().caller(), self.env().account_id());\n        }\n\n        /// Panic if `owner` is not an owner,\n        fn ensure_owner(&self, owner: &AccountId) {\n            assert!(self.is_owner.contains(owner));\n        }\n\n        /// Panic if `owner` is an owner.\n        fn ensure_no_owner(&self, owner: &AccountId) {\n            assert!(!self.is_owner.contains(owner));\n        }\n    }\n\n    /// Panic if the number of `owners` under a `requirement` violates our\n    /// requirement invariant.\n    fn ensure_requirement_is_valid(owners: u32, requirement: u32) {\n        assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use ink::env::{\n            call::utils::ArgumentList,\n            test,\n        };\n\n        const WALLET: [u8; 32] = [7; 32];\n\n        impl Transaction {\n            fn change_requirement(requirement: u32) -> Self {\n                use ink::scale::Encode;\n                let call_args = ArgumentList::empty().push_arg(&requirement);\n\n                // Multisig::change_requirement()\n                Self {\n                    callee: AccountId::from(WALLET),\n                    selector: ink::selector_bytes!(\"change_requirement\"),\n                    input: call_args.encode(),\n                    transferred_value: 0,\n                    ref_time_limit: 1000000,\n                    allow_reentry: false,\n                }\n            }\n        }\n\n        fn set_caller(sender: AccountId) {\n            ink::env::test::set_caller::<Environment>(sender);\n        }\n\n        fn set_from_wallet() {\n            let callee = AccountId::from(WALLET);\n            set_caller(callee);\n        }\n\n        fn set_from_owner() {\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n        }\n\n        fn set_from_no_owner() {\n            let accounts = default_accounts();\n            set_caller(accounts.django);\n        }\n\n        fn default_accounts() -> test::DefaultAccounts<Environment> {\n            ink::env::test::default_accounts::<Environment>()\n        }\n\n        fn build_contract() -> Multisig {\n            // Set the contract's address as `WALLET`.\n            let callee: AccountId = AccountId::from(WALLET);\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(callee);\n\n            let accounts = default_accounts();\n            let owners = vec![accounts.alice, accounts.bob, accounts.eve];\n            Multisig::new(2, owners)\n        }\n\n        fn submit_transaction() -> Multisig {\n            let mut contract = build_contract();\n            let accounts = default_accounts();\n            set_from_owner();\n            contract.submit_transaction(Transaction::change_requirement(1));\n            assert_eq!(contract.transaction_list.transactions.len(), 1);\n            assert_eq!(test::recorded_events().count(), 2);\n            let transaction = contract.transactions.get(0).unwrap();\n            assert_eq!(transaction, Transaction::change_requirement(1));\n            contract.confirmations.get((0, accounts.alice)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n            contract\n        }\n\n        #[ink::test]\n        fn construction_works() {\n            let accounts = default_accounts();\n            let owners = [accounts.alice, accounts.bob, accounts.eve];\n            let contract = build_contract();\n\n            assert_eq!(contract.owners.len(), 3);\n            assert_eq!(contract.requirement, 2);\n            assert!(contract.owners.iter().eq(owners.iter()));\n            assert!(contract.is_owner.contains(accounts.alice));\n            assert!(contract.is_owner.contains(accounts.bob));\n            assert!(contract.is_owner.contains(accounts.eve));\n            assert!(!contract.is_owner.contains(accounts.charlie));\n            assert!(!contract.is_owner.contains(accounts.django));\n            assert!(!contract.is_owner.contains(accounts.frank));\n            assert_eq!(contract.transaction_list.transactions.len(), 0);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn empty_owner_construction_fails() {\n            Multisig::new(0, vec![]);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn zero_requirement_construction_fails() {\n            let accounts = default_accounts();\n            Multisig::new(0, vec![accounts.alice, accounts.bob]);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn too_large_requirement_construction_fails() {\n            let accounts = default_accounts();\n            Multisig::new(3, vec![accounts.alice, accounts.bob]);\n        }\n\n        #[ink::test]\n        fn add_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.add_owner(accounts.frank);\n            assert_eq!(contract.owners.len(), owners + 1);\n            assert!(contract.is_owner.contains(accounts.frank));\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn add_existing_owner_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.add_owner(accounts.bob);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn add_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.add_owner(accounts.frank);\n        }\n\n        #[ink::test]\n        fn remove_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.remove_owner(accounts.alice);\n            assert_eq!(contract.owners.len(), owners - 1);\n            assert!(!contract.is_owner.contains(accounts.alice));\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn remove_owner_nonexisting_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.remove_owner(accounts.django);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn remove_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.remove_owner(accounts.alice);\n        }\n\n        #[ink::test]\n        fn replace_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.replace_owner(accounts.alice, accounts.django);\n            assert_eq!(contract.owners.len(), owners);\n            assert!(!contract.is_owner.contains(accounts.alice));\n            assert!(contract.is_owner.contains(accounts.django));\n            assert_eq!(test::recorded_events().count(), 2);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_existing_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.replace_owner(accounts.alice, accounts.bob);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_nonexisting_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.replace_owner(accounts.django, accounts.frank);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.replace_owner(accounts.alice, accounts.django);\n        }\n\n        #[ink::test]\n        fn change_requirement_works() {\n            let mut contract = build_contract();\n            assert_eq!(contract.requirement, 2);\n            set_from_wallet();\n            contract.change_requirement(3);\n            assert_eq!(contract.requirement, 3);\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn change_requirement_too_high() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.change_requirement(4);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn change_requirement_zero_fails() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.change_requirement(0);\n        }\n\n        #[ink::test]\n        fn submit_transaction_works() {\n            submit_transaction();\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn submit_transaction_no_owner_fails() {\n            let mut contract = build_contract();\n            set_from_no_owner();\n            contract.submit_transaction(Transaction::change_requirement(1));\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn submit_transaction_wallet_fails() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.submit_transaction(Transaction::change_requirement(1));\n        }\n\n        #[ink::test]\n        fn cancel_transaction_works() {\n            let mut contract = submit_transaction();\n            set_from_wallet();\n            contract.cancel_transaction(0);\n            assert_eq!(contract.transaction_list.transactions.len(), 0);\n            assert_eq!(test::recorded_events().count(), 3);\n        }\n\n        #[ink::test]\n        fn cancel_transaction_nonexisting() {\n            let mut contract = submit_transaction();\n            set_from_wallet();\n            contract.cancel_transaction(1);\n            assert_eq!(contract.transaction_list.transactions.len(), 1);\n            assert_eq!(test::recorded_events().count(), 2);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn cancel_transaction_no_permission() {\n            let mut contract = submit_transaction();\n            contract.cancel_transaction(0);\n        }\n\n        #[ink::test]\n        fn confirm_transaction_works() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.bob);\n            contract.confirm_transaction(0);\n            assert_eq!(test::recorded_events().count(), 3);\n            contract.confirmations.get((0, accounts.bob)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 2);\n        }\n\n        #[ink::test]\n        fn revoke_confirmations() {\n            // given\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            // Confirm by Bob\n            set_caller(accounts.bob);\n            contract.confirm_transaction(0);\n            // Confirm by Eve\n            set_caller(accounts.eve);\n            contract.confirm_transaction(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 3);\n            // Revoke from Eve\n            contract.revoke_confirmation(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 2);\n            // Revoke from Bob\n            set_caller(accounts.bob);\n            contract.revoke_confirmation(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        fn confirm_transaction_already_confirmed() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n            contract.confirm_transaction(0);\n            assert_eq!(test::recorded_events().count(), 2);\n            contract.confirmations.get((0, accounts.alice)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn confirm_transaction_no_owner_fail() {\n            let mut contract = submit_transaction();\n            set_from_no_owner();\n            contract.confirm_transaction(0);\n        }\n\n        #[ink::test]\n        fn revoke_transaction_works() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n            contract.revoke_confirmation(0);\n            assert_eq!(test::recorded_events().count(), 3);\n            assert!(!contract.confirmations.contains((0, accounts.alice)));\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 0);\n        }\n\n        #[ink::test]\n        fn revoke_transaction_no_confirmer() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.bob);\n            contract.revoke_confirmation(0);\n            assert_eq!(test::recorded_events().count(), 2);\n            assert!(contract.confirmations.contains((0, accounts.alice)));\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn revoke_transaction_no_owner_fail() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.django);\n            contract.revoke_confirmation(0);\n        }\n\n        #[ink::test]\n        fn execute_transaction_works() {\n            // Execution of calls is currently unsupported in off-chain test.\n            // Calling `execute_transaction` panics in any case.\n        }\n    }\n}\n"
    },
    {
      "name": "payment-channel",
      "path": "payment-channel/lib.rs",
      "code": "//! # Payment Channel\n//!\n//! This implements a payment channel between two parties.\n//!\n//! ## Warning\n//!\n//! This contract is an *example*. It is neither audited nor endorsed for production use.\n//! Do **not** rely on it to keep anything of value secure.\n//!\n//! ## Overview\n//!\n//! Each instantiation of this contract creates a payment channel between a `sender` and a\n//! `recipient`. It uses ECDSA signatures to ensure that the `recipient` can only claim\n//! the funds if it is signed by the `sender`.\n//!\n//! ## Error Handling\n//!\n//! The only panic in the contract is when the signature is invalid. For all other\n//! error cases an error is returned. Possible errors are defined in the `Error` enum.\n//!\n//! ## Interface\n//!\n//! The interface is modelled after [this blog post](https://programtheblockchain.com/posts/2018/03/02/building-long-lived-payment-channels)\n//!\n//! ### Deposits\n//!\n//! The creator of the contract, i.e the `sender`, can deposit funds to the payment\n//! channel while creating the payment channel. Any subsequent deposits can be made by\n//! transferring funds to the contract's address.\n//!\n//! ### Withdrawals\n//!\n//! The `recipient` can `withdraw` from the payment channel anytime by submitting the last\n//! `signature` received from the `sender`.\n//!\n//! The `sender` can only `withdraw` by terminating the payment channel. This is\n//! done by calling `start_sender_close` to set an expiration with a subsequent call\n//! of `claim_timeout` to claim the funds. This will terminate the payment channel.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod payment_channel {\n\n    /// Struct for storing the payment channel details.\n    /// The creator of the contract, i.e the `sender`, can deposit funds to the payment\n    /// channel while deploying the contract.\n    #[ink(storage)]\n    pub struct PaymentChannel {\n        /// The `AccountId` of the sender of the payment channel.\n        sender: AccountId,\n        /// The `AccountId` of the recipient of the payment channel.\n        recipient: AccountId,\n        /// The `Timestamp` at which the contract expires. The field is optional.\n        /// The contract never expires if set to `None`.\n        expiration: Option<Timestamp>,\n        /// The `Amount` withdrawn by the recipient.\n        withdrawn: Balance,\n        /// The `Timestamp` which will be added to the current time when the sender\n        /// wishes to close the channel. This will be set at the time of contract\n        /// instantiation.\n        close_duration: Timestamp,\n    }\n\n    /// Errors that can occur upon calling this contract.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if caller is not the `sender` while required to.\n        CallerIsNotSender,\n        /// Returned if caller is not the `recipient` while required to.\n        CallerIsNotRecipient,\n        /// Returned if the requested withdrawal amount is less than the amount\n        /// that is already already withdrawn.\n        AmountIsLessThanWithdrawn,\n        /// Returned if the requested transfer failed. This can be the case if the\n        /// contract does not have sufficient free funds or if the transfer would\n        /// have brought the contract's balance below minimum balance.\n        TransferFailed,\n        /// Returned if the contract hasn't expired yet and the `sender` wishes to\n        /// close the channel.\n        NotYetExpired,\n        /// Returned if the signature is invalid.\n        InvalidSignature,\n    }\n\n    /// Type alias for the contract's `Result` type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    /// Emitted when the sender starts closing the channel.\n    #[ink(event)]\n    pub struct SenderCloseStarted {\n        expiration: Timestamp,\n        close_duration: Timestamp,\n    }\n\n    impl PaymentChannel {\n        /// The only constructor of the contract.\n        ///\n        /// The arguments `recipient` and `close_duration` are required.\n        ///\n        /// `expiration` will be set to `None`, so that the contract will\n        /// never expire. `sender` can call `start_sender_close` to override\n        /// this. `sender` will be able to claim the remaining balance by calling\n        /// `claim_timeout` after `expiration` has passed.\n        #[ink(constructor)]\n        pub fn new(recipient: AccountId, close_duration: Timestamp) -> Self {\n            Self {\n                sender: Self::env().caller(),\n                recipient,\n                expiration: None,\n                withdrawn: 0,\n                close_duration,\n            }\n        }\n\n        /// The `recipient` can close the payment channel anytime. The specified\n        /// `amount` will be sent to the `recipient` and the remainder will go\n        /// back to the `sender`.\n        #[ink(message)]\n        pub fn close(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {\n            self.close_inner(amount, signature)?;\n            self.env().terminate_contract(self.sender);\n        }\n\n        /// We split this out in order to make testing `close` simpler.\n        fn close_inner(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {\n            if self.env().caller() != self.recipient {\n                return Err(Error::CallerIsNotRecipient)\n            }\n\n            if amount < self.withdrawn {\n                return Err(Error::AmountIsLessThanWithdrawn)\n            }\n\n            // Signature validation\n            if !self.is_signature_valid(amount, signature) {\n                return Err(Error::InvalidSignature)\n            }\n\n            // We checked that amount >= self.withdrawn\n            #[allow(clippy::arithmetic_side_effects)]\n            self.env()\n                .transfer(self.recipient, amount - self.withdrawn)\n                .map_err(|_| Error::TransferFailed)?;\n\n            Ok(())\n        }\n\n        /// If the `sender` wishes to close the channel and withdraw the funds they can\n        /// do so by setting the `expiration`. If the `expiration` is reached, the\n        /// sender will be able to call `claim_timeout` to claim the remaining funds\n        /// and the channel will be terminated. This emits an event that the recipient can\n        /// listen to in order to withdraw the funds before the `expiration`.\n        #[ink(message)]\n        pub fn start_sender_close(&mut self) -> Result<()> {\n            if self.env().caller() != self.sender {\n                return Err(Error::CallerIsNotSender)\n            }\n\n            let now = self.env().block_timestamp();\n            let expiration = now.checked_add(self.close_duration).unwrap();\n\n            self.env().emit_event(SenderCloseStarted {\n                expiration,\n                close_duration: self.close_duration,\n            });\n\n            self.expiration = Some(expiration);\n\n            Ok(())\n        }\n\n        /// If the timeout is reached (`current_time >= expiration`) without the\n        /// recipient closing the channel, then the remaining balance is released\n        /// back to the `sender`.\n        #[ink(message)]\n        pub fn claim_timeout(&mut self) -> Result<()> {\n            match self.expiration {\n                Some(expiration) => {\n                    // expiration is set. Check if it's reached and if so, release the\n                    // funds and terminate the contract.\n                    let now = self.env().block_timestamp();\n                    if now < expiration {\n                        return Err(Error::NotYetExpired)\n                    }\n\n                    self.env().terminate_contract(self.sender);\n                }\n\n                None => Err(Error::NotYetExpired),\n            }\n        }\n\n        /// The `recipient` can withdraw the funds from the channel at any time.\n        #[ink(message)]\n        pub fn withdraw(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {\n            if self.env().caller() != self.recipient {\n                return Err(Error::CallerIsNotRecipient)\n            }\n\n            // Signature validation\n            if !self.is_signature_valid(amount, signature) {\n                return Err(Error::InvalidSignature)\n            }\n\n            // Make sure there's something to withdraw (guards against underflow)\n            if amount < self.withdrawn {\n                return Err(Error::AmountIsLessThanWithdrawn)\n            }\n\n            // We checked that amount >= self.withdrawn\n            #[allow(clippy::arithmetic_side_effects)]\n            let amount_to_withdraw = amount - self.withdrawn;\n            self.withdrawn.checked_add(amount_to_withdraw).unwrap();\n\n            self.env()\n                .transfer(self.recipient, amount_to_withdraw)\n                .map_err(|_| Error::TransferFailed)?;\n\n            Ok(())\n        }\n\n        /// Returns the `sender` of the contract.\n        #[ink(message)]\n        pub fn get_sender(&self) -> AccountId {\n            self.sender\n        }\n\n        /// Returns the `recipient` of the contract.\n        #[ink(message)]\n        pub fn get_recipient(&self) -> AccountId {\n            self.recipient\n        }\n\n        /// Returns the `expiration` of the contract.\n        #[ink(message)]\n        pub fn get_expiration(&self) -> Option<Timestamp> {\n            self.expiration\n        }\n\n        /// Returns the `withdrawn` amount of the contract.\n        #[ink(message)]\n        pub fn get_withdrawn(&self) -> Balance {\n            self.withdrawn\n        }\n\n        /// Returns the `close_duration` of the contract.\n        #[ink(message)]\n        pub fn get_close_duration(&self) -> Timestamp {\n            self.close_duration\n        }\n\n        /// Returns the `balance` of the contract.\n        #[ink(message)]\n        pub fn get_balance(&self) -> Balance {\n            self.env().balance()\n        }\n    }\n\n    #[ink(impl)]\n    impl PaymentChannel {\n        fn is_signature_valid(&self, amount: Balance, signature: [u8; 65]) -> bool {\n            let encodable = (self.env().account_id(), amount);\n            let mut message =\n                <ink::env::hash::Sha2x256 as ink::env::hash::HashOutput>::Type::default();\n            ink::env::hash_encoded::<ink::env::hash::Sha2x256, _>(\n                &encodable,\n                &mut message,\n            );\n\n            let mut pub_key = [0; 33];\n            ink::env::ecdsa_recover(&signature, &message, &mut pub_key)\n                .unwrap_or_else(|err| panic!(\"recover failed: {err:?}\"));\n            let mut signature_account_id = [0; 32];\n            <ink::env::hash::Blake2x256 as ink::env::hash::CryptoHash>::hash(\n                &pub_key,\n                &mut signature_account_id,\n            );\n\n            self.recipient == signature_account_id.into()\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use hex_literal;\n        use sp_core::{\n            Encode,\n            Pair,\n        };\n\n        fn default_accounts(\n        ) -> ink::env::test::DefaultAccounts<ink::env::DefaultEnvironment> {\n            ink::env::test::default_accounts::<ink::env::DefaultEnvironment>()\n        }\n\n        fn set_next_caller(caller: AccountId) {\n            ink::env::test::set_caller::<ink::env::DefaultEnvironment>(caller);\n        }\n\n        fn set_account_balance(account: AccountId, balance: Balance) {\n            ink::env::test::set_account_balance::<ink::env::DefaultEnvironment>(\n                account, balance,\n            );\n        }\n\n        fn get_account_balance(account: AccountId) -> Balance {\n            ink::env::test::get_account_balance::<ink::env::DefaultEnvironment>(account)\n                .expect(\"Cannot get account balance\")\n        }\n\n        fn advance_block() {\n            ink::env::test::advance_block::<ink::env::DefaultEnvironment>();\n        }\n\n        fn get_current_time() -> Timestamp {\n            let since_the_epoch = std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .expect(\"Time went backwards\");\n            since_the_epoch.as_secs()\n                + since_the_epoch.subsec_nanos() as u64 / 1_000_000_000\n        }\n\n        fn get_dan() -> AccountId {\n            // Use Dan's seed\n            // `subkey inspect //Dan --scheme Ecdsa --output-type json | jq .secretSeed`\n            let seed = hex_literal::hex!(\n                \"c31fa562972de437802e0df146b16146349590b444db41f7e3eb9deedeee6f64\"\n            );\n            let pair = sp_core::ecdsa::Pair::from_seed(&seed);\n            let pub_key = pair.public();\n            let compressed_pub_key: [u8; 33] = pub_key.encode()[..]\n                .try_into()\n                .expect(\"slice with incorrect length\");\n            let mut account_id = [0; 32];\n            <ink::env::hash::Blake2x256 as ink::env::hash::CryptoHash>::hash(\n                &compressed_pub_key,\n                &mut account_id,\n            );\n            account_id.into()\n        }\n\n        fn contract_id() -> AccountId {\n            let accounts = default_accounts();\n            let contract_id = accounts.charlie;\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(contract_id);\n            contract_id\n        }\n\n        fn sign(contract_id: AccountId, amount: Balance) -> [u8; 65] {\n            let encodable = (contract_id, amount);\n            let mut hash =\n                <ink::env::hash::Sha2x256 as ink::env::hash::HashOutput>::Type::default(); // 256-bit buffer\n            ink::env::hash_encoded::<ink::env::hash::Sha2x256, _>(&encodable, &mut hash);\n\n            // Use Dan's seed\n            // `subkey inspect //Dan --scheme Ecdsa --output-type json | jq .secretSeed`\n            let seed = hex_literal::hex!(\n                \"c31fa562972de437802e0df146b16146349590b444db41f7e3eb9deedeee6f64\"\n            );\n            let pair = sp_core::ecdsa::Pair::from_seed(&seed);\n\n            let signature = pair.sign_prehashed(&hash);\n            signature.0\n        }\n\n        #[ink::test]\n        fn test_deposit() {\n            // given\n            let accounts = default_accounts();\n            let initial_balance = 10_000;\n            let close_duration = 360_000;\n            let mock_deposit_value = 1_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(accounts.bob, initial_balance);\n\n            // when\n            // Push the new execution context with Alice as the caller and\n            // the `mock_deposit_value` as the value deposited.\n            // Note: Currently there is no way to transfer funds to the contract.\n            set_next_caller(accounts.alice);\n            let payment_channel = PaymentChannel::new(accounts.bob, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n\n            // then\n            assert_eq!(payment_channel.get_balance(), mock_deposit_value);\n        }\n\n        #[ink::test]\n        fn test_close() {\n            // given\n            let accounts = default_accounts();\n            let dan = get_dan();\n            let close_duration = 360_000;\n            let mock_deposit_value = 1_000;\n            let amount = 500;\n            let initial_balance = 10_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(dan, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let mut payment_channel = PaymentChannel::new(dan, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n            set_next_caller(dan);\n            let signature = sign(contract_id, amount);\n\n            // then\n            let should_close = move || payment_channel.close(amount, signature).unwrap();\n            ink::env::test::assert_contract_termination::<ink::env::DefaultEnvironment, _>(\n                should_close,\n                accounts.alice,\n                amount,\n            );\n            assert_eq!(get_account_balance(dan), initial_balance + amount);\n        }\n\n        #[ink::test]\n        fn close_fails_invalid_signature() {\n            // given\n            let accounts = default_accounts();\n            let dan = get_dan();\n            let mock_deposit_value = 1_000;\n            let close_duration = 360_000;\n            let amount = 400;\n            let unexpected_amount = amount + 1;\n            let initial_balance = 10_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(dan, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let mut payment_channel = PaymentChannel::new(dan, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n            set_next_caller(dan);\n            let signature = sign(contract_id, amount);\n\n            // then\n            let res = payment_channel.close_inner(unexpected_amount, signature);\n            assert!(res.is_err(), \"Expected an error, got {res:?} instead.\");\n            assert_eq!(res.unwrap_err(), Error::InvalidSignature,);\n        }\n\n        #[ink::test]\n        fn test_withdraw() {\n            // given\n            let accounts = default_accounts();\n            let dan = get_dan();\n            let initial_balance = 10_000;\n            let mock_deposit_value = 1_000;\n            let close_duration = 360_000;\n            let amount = 500;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(dan, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let mut payment_channel = PaymentChannel::new(dan, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n\n            set_next_caller(dan);\n            let signature = sign(contract_id, amount);\n            payment_channel\n                .withdraw(amount, signature)\n                .expect(\"withdraw failed\");\n\n            // then\n            assert_eq!(payment_channel.get_balance(), amount);\n            assert_eq!(get_account_balance(dan), initial_balance + amount);\n        }\n\n        #[ink::test]\n        fn withdraw_fails_invalid_signature() {\n            // given\n            let accounts = default_accounts();\n            let dan = get_dan();\n            let initial_balance = 10_000;\n            let close_duration = 360_000;\n            let amount = 400;\n            let unexpected_amount = amount + 1;\n            let mock_deposit_value = 1_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(dan, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let mut payment_channel = PaymentChannel::new(dan, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n            set_next_caller(dan);\n            let signature = sign(contract_id, amount);\n\n            // then\n            let res = payment_channel.withdraw(unexpected_amount, signature);\n            assert!(res.is_err(), \"Expected an error, got {res:?} instead.\");\n            assert_eq!(res.unwrap_err(), Error::InvalidSignature,);\n        }\n\n        #[ink::test]\n        fn test_start_sender_close() {\n            // given\n            let accounts = default_accounts();\n            let initial_balance = 10_000;\n            let mock_deposit_value = 1_000;\n            let close_duration = 1;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(accounts.bob, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let mut payment_channel = PaymentChannel::new(accounts.bob, close_duration);\n            let contract_id = contract_id();\n            set_account_balance(contract_id, mock_deposit_value);\n\n            payment_channel\n                .start_sender_close()\n                .expect(\"start_sender_close failed\");\n            advance_block();\n\n            // then\n            let now = get_current_time();\n            assert!(now > payment_channel.get_expiration().unwrap());\n        }\n\n        #[ink::test]\n        fn test_claim_timeout() {\n            // given\n            let accounts = default_accounts();\n            let initial_balance = 10_000;\n            let close_duration = 1;\n            let mock_deposit_value = 1_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(accounts.bob, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let contract_id = contract_id();\n            let mut payment_channel = PaymentChannel::new(accounts.bob, close_duration);\n            set_account_balance(contract_id, mock_deposit_value);\n\n            payment_channel\n                .start_sender_close()\n                .expect(\"start_sender_close failed\");\n            advance_block();\n\n            // then\n            let should_close = move || payment_channel.claim_timeout().unwrap();\n            ink::env::test::assert_contract_termination::<ink::env::DefaultEnvironment, _>(\n                should_close,\n                accounts.alice,\n                mock_deposit_value,\n            );\n            assert_eq!(\n                get_account_balance(accounts.alice),\n                initial_balance + mock_deposit_value\n            );\n        }\n\n        #[ink::test]\n        fn test_getters() {\n            // given\n            let accounts = default_accounts();\n            let initial_balance = 10_000;\n            let mock_deposit_value = 1_000;\n            let close_duration = 360_000;\n            set_account_balance(accounts.alice, initial_balance);\n            set_account_balance(accounts.bob, initial_balance);\n\n            // when\n            set_next_caller(accounts.alice);\n            let contract_id = contract_id();\n            let payment_channel = PaymentChannel::new(accounts.bob, close_duration);\n            set_account_balance(contract_id, mock_deposit_value);\n\n            // then\n            assert_eq!(payment_channel.get_sender(), accounts.alice);\n            assert_eq!(payment_channel.get_recipient(), accounts.bob);\n            assert_eq!(payment_channel.get_balance(), mock_deposit_value);\n            assert_eq!(payment_channel.get_close_duration(), close_duration);\n            assert_eq!(payment_channel.get_withdrawn(), 0);\n        }\n    }\n}\n"
    },
    {
      "name": "psp22-extension",
      "path": "psp22-extension/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nuse ink::{\n    env::Environment,\n    prelude::vec::Vec,\n};\n\ntype DefaultAccountId = <ink::env::DefaultEnvironment as Environment>::AccountId;\ntype DefaultBalance = <ink::env::DefaultEnvironment as Environment>::Balance;\n\n#[ink::chain_extension(extension = 13)]\npub trait Psp22Extension {\n    type ErrorCode = Psp22Error;\n\n    // PSP22 Metadata interfaces\n\n    #[ink(function = 0x3d26)]\n    fn token_name(asset_id: u32) -> Result<Vec<u8>>;\n\n    #[ink(function = 0x3420)]\n    fn token_symbol(asset_id: u32) -> Result<Vec<u8>>;\n\n    #[ink(function = 0x7271)]\n    fn token_decimals(asset_id: u32) -> Result<u8>;\n\n    // PSP22 interface queries\n\n    #[ink(function = 0x162d)]\n    fn total_supply(asset_id: u32) -> Result<DefaultBalance>;\n\n    #[ink(function = 0x6568)]\n    fn balance_of(asset_id: u32, owner: DefaultAccountId) -> Result<DefaultBalance>;\n\n    #[ink(function = 0x4d47)]\n    fn allowance(\n        asset_id: u32,\n        owner: DefaultAccountId,\n        spender: DefaultAccountId,\n    ) -> Result<DefaultBalance>;\n\n    // PSP22 transfer\n    #[ink(function = 0xdb20)]\n    fn transfer(asset_id: u32, to: DefaultAccountId, value: DefaultBalance)\n        -> Result<()>;\n\n    // PSP22 transfer_from\n    #[ink(function = 0x54b3)]\n    fn transfer_from(\n        asset_id: u32,\n        from: DefaultAccountId,\n        to: DefaultAccountId,\n        value: DefaultBalance,\n    ) -> Result<()>;\n\n    // PSP22 approve\n    #[ink(function = 0xb20f)]\n    fn approve(\n        asset_id: u32,\n        spender: DefaultAccountId,\n        value: DefaultBalance,\n    ) -> Result<()>;\n\n    // PSP22 increase_allowance\n    #[ink(function = 0x96d6)]\n    fn increase_allowance(\n        asset_id: u32,\n        spender: DefaultAccountId,\n        value: DefaultBalance,\n    ) -> Result<()>;\n\n    // PSP22 decrease_allowance\n    #[ink(function = 0xfecb)]\n    fn decrease_allowance(\n        asset_id: u32,\n        spender: DefaultAccountId,\n        value: DefaultBalance,\n    ) -> Result<()>;\n}\n\n#[derive(Debug, PartialEq, Eq)]\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\npub enum Psp22Error {\n    TotalSupplyFailed,\n}\n\npub type Result<T> = core::result::Result<T, Psp22Error>;\n\nimpl From<ink::scale::Error> for Psp22Error {\n    fn from(_: ink::scale::Error) -> Self {\n        panic!(\"encountered unexpected invalid SCALE encoding\")\n    }\n}\n\nimpl ink::env::chain_extension::FromStatusCode for Psp22Error {\n    fn from_status_code(status_code: u32) -> core::result::Result<(), Self> {\n        match status_code {\n            0 => Ok(()),\n            1 => Err(Self::TotalSupplyFailed),\n            _ => panic!(\"encountered unknown status code\"),\n        }\n    }\n}\n\n/// An environment using default ink environment types, with PSP-22 extension included\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[ink::scale_derive(TypeInfo)]\npub enum CustomEnvironment {}\n\nimpl Environment for CustomEnvironment {\n    const MAX_EVENT_TOPICS: usize =\n        <ink::env::DefaultEnvironment as Environment>::MAX_EVENT_TOPICS;\n\n    type AccountId = DefaultAccountId;\n    type Balance = DefaultBalance;\n    type Hash = <ink::env::DefaultEnvironment as Environment>::Hash;\n    type Timestamp = <ink::env::DefaultEnvironment as Environment>::Timestamp;\n    type BlockNumber = <ink::env::DefaultEnvironment as Environment>::BlockNumber;\n\n    type ChainExtension = crate::Psp22Extension;\n}\n\n#[ink::contract(env = crate::CustomEnvironment)]\nmod psp22_ext {\n    use super::{\n        Result,\n        Vec,\n    };\n\n    /// A chain extension which implements the PSP-22 fungible token standard.\n    /// For more details see <https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md>\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Psp22Extension {}\n\n    impl Psp22Extension {\n        /// Creates a new instance of this contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        // PSP22 Metadata interfaces\n\n        /// Returns the token name of the specified asset.\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self, asset_id: u32) -> Result<Vec<u8>> {\n            self.env().extension().token_name(asset_id)\n        }\n\n        /// Returns the token symbol of the specified asset.\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self, asset_id: u32) -> Result<Vec<u8>> {\n            self.env().extension().token_symbol(asset_id)\n        }\n\n        /// Returns the token decimals of the specified asset.\n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self, asset_id: u32) -> Result<u8> {\n            self.env().extension().token_decimals(asset_id)\n        }\n\n        // PSP22 interface queries\n\n        /// Returns the total token supply of the specified asset.\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self, asset_id: u32) -> Result<Balance> {\n            self.env().extension().total_supply(asset_id)\n        }\n\n        /// Returns the account balance for the specified asset & owner.\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, asset_id: u32, owner: AccountId) -> Result<Balance> {\n            self.env().extension().balance_of(asset_id, owner)\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`\n        /// for the specified asset.\n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(\n            &self,\n            asset_id: u32,\n            owner: AccountId,\n            spender: AccountId,\n        ) -> Result<Balance> {\n            self.env().extension().allowance(asset_id, owner, spender)\n        }\n\n        // PSP22 transfer\n\n        /// Transfers `value` amount of specified asset from the caller's account to the\n        /// account `to`.\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(\n            &mut self,\n            asset_id: u32,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            self.env().extension().transfer(asset_id, to, value)\n        }\n\n        // PSP22 transfer_from\n\n        /// Transfers `value` amount of specified asset on the behalf of `from` to the\n        /// account `to`.\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(\n            &mut self,\n            asset_id: u32,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            self.env()\n                .extension()\n                .transfer_from(asset_id, from, to, value)\n        }\n\n        // PSP22 approve\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount of the specified asset.\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(\n            &mut self,\n            asset_id: u32,\n            spender: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            self.env().extension().approve(asset_id, spender, value)\n        }\n\n        // PSP22 increase_allowance\n\n        /// Atomically increases the allowance for the specified asset granted to\n        /// `spender` by the caller.\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(\n            &mut self,\n            asset_id: u32,\n            spender: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            self.env()\n                .extension()\n                .increase_allowance(asset_id, spender, value)\n        }\n\n        // PSP22 decrease_allowance\n\n        /// Atomically decreases the allowance for the specified asset granted to\n        /// `spender` by the caller.\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(\n            &mut self,\n            asset_id: u32,\n            spender: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            self.env()\n                .extension()\n                .decrease_allowance(asset_id, spender, value)\n        }\n    }\n}\n"
    },
    {
      "name": "rand-extension",
      "path": "rand-extension/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nuse ink::env::Environment;\n\n/// This is an example of how an ink! contract may call the Substrate\n/// runtime function `RandomnessCollectiveFlip::random_seed`. See the\n/// file `runtime/chain-extension-example.rs` for that implementation.\n///\n/// Here we define the operations to interact with the Substrate runtime.\n#[ink::chain_extension(extension = 666)]\npub trait FetchRandom {\n    type ErrorCode = RandomReadErr;\n\n    /// Note: this gives the operation a corresponding `func_id` (1101 in this case),\n    /// and the chain-side chain extension will get the `func_id` to do further\n    /// operations.\n    #[ink(function = 1101)]\n    fn fetch_random(subject: [u8; 32]) -> [u8; 32];\n}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\npub enum RandomReadErr {\n    FailGetRandomSource,\n}\n\nimpl ink::env::chain_extension::FromStatusCode for RandomReadErr {\n    fn from_status_code(status_code: u32) -> Result<(), Self> {\n        match status_code {\n            0 => Ok(()),\n            1 => Err(Self::FailGetRandomSource),\n            _ => panic!(\"encountered unknown status code\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[ink::scale_derive(TypeInfo)]\npub enum CustomEnvironment {}\n\nimpl Environment for CustomEnvironment {\n    const MAX_EVENT_TOPICS: usize =\n        <ink::env::DefaultEnvironment as Environment>::MAX_EVENT_TOPICS;\n\n    type AccountId = <ink::env::DefaultEnvironment as Environment>::AccountId;\n    type Balance = <ink::env::DefaultEnvironment as Environment>::Balance;\n    type Hash = <ink::env::DefaultEnvironment as Environment>::Hash;\n    type BlockNumber = <ink::env::DefaultEnvironment as Environment>::BlockNumber;\n    type Timestamp = <ink::env::DefaultEnvironment as Environment>::Timestamp;\n\n    type ChainExtension = FetchRandom;\n}\n\n#[ink::contract(env = crate::CustomEnvironment)]\nmod rand_extension {\n    use super::RandomReadErr;\n\n    /// Defines the storage of our contract.\n    ///\n    /// Here we store the random seed fetched from the chain.\n    #[ink(storage)]\n    pub struct RandExtension {\n        /// Stores a single `bool` value on the storage.\n        value: [u8; 32],\n    }\n\n    #[ink(event)]\n    pub struct RandomUpdated {\n        #[ink(topic)]\n        new: [u8; 32],\n    }\n\n    impl RandExtension {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: [u8; 32]) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Constructor that initializes the `bool` value to `false`.\n        ///\n        /// Constructors may delegate to other constructors.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Seed a random value by passing some known argument `subject` to the runtime's\n        /// random source. Then, update the current `value` stored in this contract with\n        /// the new random value.\n        #[ink(message)]\n        pub fn update(&mut self, subject: [u8; 32]) -> Result<(), RandomReadErr> {\n            // Get the on-chain random seed\n            let new_random = self.env().extension().fetch_random(subject)?;\n            self.value = new_random;\n            // Emit the `RandomUpdated` event when the random seed\n            // is successfully fetched.\n            self.env().emit_event(RandomUpdated { new: new_random });\n            Ok(())\n        }\n\n        /// Simply returns the current value.\n        #[ink(message)]\n        pub fn get(&self) -> [u8; 32] {\n            self.value\n        }\n    }\n\n    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n\n        /// We test if the default constructor does its job.\n        #[ink::test]\n        fn default_works() {\n            let rand_extension = RandExtension::new_default();\n            assert_eq!(rand_extension.get(), [0; 32]);\n        }\n\n        #[ink::test]\n        fn chain_extension_works() {\n            // given\n            struct MockedRandExtension;\n            impl ink::env::test::ChainExtension for MockedRandExtension {\n                /// The static function id of the chain extension.\n                fn ext_id(&self) -> u16 {\n                    666\n                }\n\n                /// The chain extension is called with the given input.\n                ///\n                /// Returns an error code and may fill the `output` buffer with a\n                /// SCALE encoded result. The error code is taken from the\n                /// `ink::env::chain_extension::FromStatusCode` implementation for\n                /// `RandomReadErr`.\n                fn call(\n                    &mut self,\n                    _func_id: u16,\n                    _input: &[u8],\n                    output: &mut Vec<u8>,\n                ) -> u32 {\n                    let ret: [u8; 32] = [1; 32];\n                    ink::scale::Encode::encode_to(&ret, output);\n                    0\n                }\n            }\n            ink::env::test::register_chain_extension(MockedRandExtension);\n            let mut rand_extension = RandExtension::new_default();\n            assert_eq!(rand_extension.get(), [0; 32]);\n\n            // when\n            rand_extension.update([0_u8; 32]).expect(\"update must work\");\n\n            // then\n            assert_eq!(rand_extension.get(), [1; 32]);\n        }\n    }\n}\n"
    },
    {
      "name": "runtime-call-contract",
      "path": "runtime-call-contract/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use flipper::{\n    Flipper,\n    FlipperRef,\n};\n\n#[ink::contract]\nmod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n    }\n\n    impl flipper_traits::Flip for Flipper {\n        #[ink(message)]\n        fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        #[ink(message)]\n        fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n\n#[cfg(test)]\nmod e2e_tests;\n"
    },
    {
      "name": "src",
      "path": "runtime-call-contract/sandbox-runtime/pallet-contract-caller/src/lib.rs",
      "code": "//! # Contract Caller\n//!\n//! Demonstrates calling into an `ink!` contract from a pallet.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nmod executor;\n\nuse frame_support::{\n    pallet_prelude::Weight,\n    traits::fungible::Inspect,\n};\npub use pallet::*;\n\ntype AccountIdOf<R> = <R as frame_system::Config>::AccountId;\ntype BalanceOf<R> = <<R as pallet_contracts::Config>::Currency as Inspect<\n    <R as frame_system::Config>::AccountId,\n>>::Balance;\n\n#[frame_support::pallet]\npub mod pallet {\n    use super::*;\n    use flipper_traits::Flip;\n    use frame_support::{\n        pallet_prelude::*,\n        traits::fungible::Inspect,\n    };\n    use frame_system::pallet_prelude::*;\n\n    #[pallet::pallet]\n    pub struct Pallet<T>(_);\n\n    #[pallet::config]\n    pub trait Config: frame_system::Config + pallet_contracts::Config {}\n\n    #[pallet::error]\n    pub enum Error<T> {}\n\n    #[pallet::call]\n    impl<T: Config> Pallet<T>\n    where\n        [u8; 32]: From<<T as frame_system::Config>::AccountId>,\n        <<T as pallet_contracts::Config>::Currency as Inspect<\n            <T as frame_system::Config>::AccountId,\n        >>::Balance: From<u128>,\n    {\n        /// Call the flip method on the contract at the given `contract` account.\n        #[pallet::call_index(0)]\n        #[pallet::weight(<T::WeightInfo as pallet_contracts::WeightInfo>::call().saturating_add(*gas_limit))]\n        pub fn contract_call_flip(\n            origin: OriginFor<T>,\n            contract: AccountIdOf<T>,\n            gas_limit: Weight,\n            storage_deposit_limit: Option<BalanceOf<T>>,\n        ) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let executor =\n                executor::PalletContractsExecutor::<ink::env::DefaultEnvironment, T> {\n                    origin: who.clone(),\n                    contract: contract.clone(),\n                    value: 0.into(),\n                    gas_limit,\n                    storage_deposit_limit,\n                    marker: Default::default(),\n                };\n\n            let mut flipper = ink::message_builder!(Flip);\n            let result = flipper.flip().exec(&executor)?;\n\n            assert!(result.is_ok());\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "src",
      "path": "runtime-call-contract/sandbox-runtime/src/lib.rs",
      "code": "//! # Contract Caller\n//!\n//! Demonstrates calling into an `ink!` contract from a pallet.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nink_sandbox::create_sandbox!(ContractCallerSandbox, ContractCallerSandboxRuntime, (), (), {\n    ContractCaller: pallet_contract_caller,\n});\n\nimpl pallet_contract_caller::Config for ContractCallerSandboxRuntime {}\n"
    },
    {
      "name": "traits",
      "path": "runtime-call-contract/traits/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n/// Allows to flip and get a bool value.\n#[ink::trait_definition]\npub trait Flip {\n    /// Flip the value of the stored `bool` from `true`\n    /// to `false` and vice versa.\n    #[ink(message)]\n    fn flip(&mut self);\n\n    /// Returns the current value of our `bool`.\n    #[ink(message)]\n    fn get(&self) -> bool;\n}\n"
    },
    {
      "name": "static-buffer",
      "path": "static-buffer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod static_buffer {\n    use ink::prelude::{\n        string::String,\n        vec::Vec,\n    };\n\n    #[allow(unused_imports)]\n    use ink::env::BUFFER_SIZE;\n    #[ink(storage)]\n    pub struct StaticBuffer {\n        value: bool,\n    }\n\n    impl StaticBuffer {\n        /// Creates a dummy smart contract.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Sets a default value.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Returns the caller of the contract.\n        /// Should panic if the buffer size is less than 32 bytes.\n        #[ink(message)]\n        pub fn get_caller(&self) -> AccountId {\n            self.env().caller()\n        }\n\n        #[ink(message)]\n        pub fn buffer(&self) -> Result<(u64, u64), String> {\n            let buf1 = Vec::<u8>::with_capacity(3);\n            let buf2 = Vec::<u64>::with_capacity(1);\n            let ptr1 = buf1.as_ptr() as u64;\n            let ptr2 = buf2.as_ptr() as u64;\n            let align = core::mem::align_of::<Vec<u64>>() as u64;\n            let padding = ptr2\n                .checked_sub(ptr1)\n                .ok_or(String::from(\"Error during padding calculation\"))?;\n            Ok((padding, align))\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        #[should_panic(expected = \"the output buffer is too small!\")]\n        fn run_out_buffer_memory() {\n            let flipper = StaticBuffer::new(false);\n            flipper.get_caller()\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn e2e_run_out_of_buffer_memory<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = StaticBufferRef::new(false);\n            let contract = client\n                .instantiate(\"static_buffer\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let call_builder = contract.call_builder::<StaticBuffer>();\n\n            // when\n            let get = call_builder.get_caller();\n            // then panics if `INK_STATIC_BUFFER_SIZE` is less than 32 bytes.\n            let res = client.call(&ink_e2e::bob(), &get).dry_run().await;\n            println!(\"{}\", super::BUFFER_SIZE);\n            assert!(\n                res.is_err(),\n                \"Buffer size was larger than expected: {}\",\n                super::BUFFER_SIZE.to_string()\n            );\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn buffer<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = StaticBufferRef::new_default();\n\n            // when\n            let contract = client\n                .instantiate(\"static_buffer\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let call_builder = contract.call_builder::<StaticBuffer>();\n\n            // then\n            let buffer_call = call_builder.buffer();\n            let buffer_call_res =\n                client.call(&ink_e2e::bob(), &buffer_call).submit().await?;\n            let value = buffer_call_res.return_value();\n            assert!(value.is_ok());\n            let value = value.unwrap();\n            let padding = value.0;\n            let align = value.1;\n            assert_eq!(padding, 8);\n            assert_eq!(align, 4);\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "incrementer",
      "path": "trait-dyn-cross-contract-calls/contracts/incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod incrementer {\n    use dyn_traits::Increment;\n\n    /// A concrete incrementer smart contract.\n    #[ink(storage)]\n    pub struct Incrementer {\n        value: u64,\n    }\n\n    impl Incrementer {\n        /// Creates a new incrementer smart contract initialized with zero.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                value: u64::default(),\n            }\n        }\n\n        /// Increases the value of the incrementer by an amount.\n        #[ink(message)]\n        pub fn inc_by(&mut self, delta: u64) {\n            self.value = self.value.checked_add(delta).unwrap();\n        }\n    }\n\n    impl Increment for Incrementer {\n        #[ink(message)]\n        fn inc(&mut self) {\n            self.inc_by(1)\n        }\n\n        #[ink(message)]\n        fn get(&self) -> u64 {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn it_works() {\n            let mut incrementer = Incrementer::new();\n            // Can call using universal call syntax using the trait.\n            assert_eq!(<Incrementer as Increment>::get(&incrementer), 0);\n            <Incrementer as Increment>::inc(&mut incrementer);\n            // Normal call syntax possible to as long as the trait is in scope.\n            assert_eq!(incrementer.get(), 1);\n        }\n    }\n}\n"
    },
    {
      "name": "trait-dyn-cross-contract-calls",
      "path": "trait-dyn-cross-contract-calls/lib.rs",
      "code": "//! This crate contains the `Caller` contract with no functionality except forwarding\n//! all calls to the `trait_incrementer::Incrementer` contract.\n//!\n//! The `Caller` doesn't use the `trait_incrementer::IncrementerRef`. Instead,\n//! all interactions with the `Incrementer` is done through the wrapper from\n//! `ink::contract_ref!` and the trait `dyn_traits::Increment`.\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod caller {\n    use dyn_traits::Increment;\n\n    /// The caller of the incrementer smart contract.\n    #[ink(storage)]\n    pub struct Caller {\n        /// Here we accept a type which implements the `Incrementer` ink! trait.\n        incrementer: ink::contract_ref!(Increment),\n    }\n\n    impl Caller {\n        /// Creates a new caller smart contract around the `incrementer` account id.\n        #[ink(constructor)]\n        pub fn new(incrementer: AccountId) -> Self {\n            Self {\n                incrementer: incrementer.into(),\n            }\n        }\n    }\n\n    impl Increment for Caller {\n        #[ink(message)]\n        fn inc(&mut self) {\n            self.incrementer.inc()\n        }\n\n        #[ink(message)]\n        fn get(&self) -> u64 {\n            self.incrementer.get()\n        }\n    }\n}\n\n#[cfg(all(test, feature = \"e2e-tests\"))]\nmod e2e_tests {\n    use super::caller::{\n        Caller,\n        CallerRef,\n    };\n    use dyn_traits::Increment;\n    use ink_e2e::ContractsBackend;\n    use trait_incrementer::incrementer::{\n        Incrementer,\n        IncrementerRef,\n    };\n\n    type E2EResult<T> = Result<T, Box<dyn std::error::Error>>;\n\n    /// A test deploys and instantiates the `trait_incrementer::Incrementer` and\n    /// `trait_incrementer_caller::Caller` contracts, where the `Caller` uses the account\n    /// id of the `Incrementer` for instantiation.\n    ///\n    /// The test verifies that we can increment the value of the `Incrementer` contract\n    /// through the `Caller` contract.\n    #[ink_e2e::test]\n    async fn e2e_cross_contract_calls<Client: E2EBackend>(\n        mut client: Client,\n    ) -> E2EResult<()> {\n        let _ = client\n            .upload(\"trait-incrementer\", &ink_e2e::alice())\n            .submit()\n            .await\n            .expect(\"uploading `trait-incrementer` failed\")\n            .code_hash;\n\n        let _ = client\n            .upload(\"trait-incrementer-caller\", &ink_e2e::alice())\n            .submit()\n            .await\n            .expect(\"uploading `trait-incrementer-caller` failed\")\n            .code_hash;\n\n        let mut constructor = IncrementerRef::new();\n\n        let incrementer = client\n            .instantiate(\"trait-incrementer\", &ink_e2e::alice(), &mut constructor)\n            .submit()\n            .await\n            .expect(\"instantiate failed\");\n        let incrementer_call = incrementer.call_builder::<Incrementer>();\n\n        let mut constructor = CallerRef::new(incrementer.account_id.clone());\n\n        let caller = client\n            .instantiate(\n                \"trait-incrementer-caller\",\n                &ink_e2e::alice(),\n                &mut constructor,\n            )\n            .submit()\n            .await\n            .expect(\"instantiate failed\");\n        let mut caller_call = caller.call_builder::<Caller>();\n\n        // Check through the caller that the value of the incrementer is zero\n        let get = caller_call.get();\n        let value = client\n            .call(&ink_e2e::alice(), &get)\n            .dry_run()\n            .await?\n            .return_value();\n        assert_eq!(value, 0);\n\n        // Increment the value of the incrementer via the caller\n        let inc = caller_call.inc();\n        let _ = client\n            .call(&ink_e2e::alice(), &inc)\n            .submit()\n            .await\n            .expect(\"calling `inc` failed\");\n\n        // Ask the `trait-increment` about a value. It should be updated by the caller.\n        // Also use `contract_ref!(Increment)` instead of `IncrementerRef`\n        // to check that it also works with e2e testing.\n        let get = incrementer_call.get();\n        let value = client\n            .call(&ink_e2e::alice(), &get)\n            .dry_run()\n            .await?\n            .return_value();\n        assert_eq!(value, 1);\n\n        Ok(())\n    }\n}\n"
    },
    {
      "name": "traits",
      "path": "trait-dyn-cross-contract-calls/traits/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n//! The trait is extracted into a separate crate to show how to do cross-contract\n//! calls only with traits without importing the contract.\n\n/// Allows to increment and get the current value.\n#[ink::trait_definition]\npub trait Increment {\n    /// Increments the current value of the implementer by one (1).\n    #[ink(message)]\n    fn inc(&mut self);\n\n    /// Returns the current value of the implementer.\n    #[ink(message)]\n    fn get(&self) -> u64;\n}\n"
    },
    {
      "name": "trait-erc20",
      "path": "trait-erc20/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod erc20 {\n    use ink::storage::Mapping;\n\n    /// The ERC-20 error types.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if not enough balance to fulfill a request is available.\n        InsufficientBalance,\n        /// Returned if not enough allowance to fulfill a request is available.\n        InsufficientAllowance,\n    }\n\n    /// The ERC-20 result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    /// Trait implemented by all ERC-20 respecting smart contracts.\n    #[ink::trait_definition]\n    pub trait BaseErc20 {\n        /// Returns the total token supply.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance;\n\n        /// Returns the account balance for the specified `owner`.\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance;\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        #[ink(message)]\n        fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance;\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        #[ink(message)]\n        fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()>;\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount.\n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()>;\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        #[ink(message)]\n        fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()>;\n    }\n\n    /// A simple ERC-20 contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Erc20 {\n        /// Total token supply.\n        total_supply: Balance,\n        /// Mapping from owner to number of owned token.\n        balances: Mapping<AccountId, Balance>,\n        /// Mapping of the token amount which an account is allowed to withdraw\n        /// from another account.\n        allowances: Mapping<(AccountId, AccountId), Balance>,\n    }\n\n    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        spender: AccountId,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    impl Erc20 {\n        /// Creates a new ERC-20 contract with the specified initial supply.\n        #[ink(constructor)]\n        pub fn new(total_supply: Balance) -> Self {\n            let mut balances = Mapping::default();\n            let caller = Self::env().caller();\n            balances.insert(caller, &total_supply);\n            Self::env().emit_event(Transfer {\n                from: None,\n                to: Some(caller),\n                value: total_supply,\n            });\n            Self {\n                total_supply,\n                balances,\n                allowances: Default::default(),\n            }\n        }\n    }\n\n    impl BaseErc20 for Erc20 {\n        /// Returns the total token supply.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balance_of_impl(&owner)\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        #[ink(message)]\n        fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            self.allowance_impl(&owner, &spender)\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        #[ink(message)]\n        fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            let from = self.env().caller();\n            self.transfer_from_to(&from, &to, value)\n        }\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount.\n        ///\n        /// If this function is called again it overwrites the current allowance with\n        /// `value`.\n        ///\n        /// An `Approval` event is emitted.\n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            let owner = self.env().caller();\n            self.allowances.insert((&owner, &spender), &value);\n            self.env().emit_event(Approval {\n                owner,\n                spender,\n                value,\n            });\n            Ok(())\n        }\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        ///\n        /// This can be used to allow a contract to transfer tokens on ones behalf and/or\n        /// to charge fees in sub-currencies, for example.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientAllowance` error if there are not enough tokens allowed\n        /// for the caller to withdraw from `from`.\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the account balance of `from`.\n        #[ink(message)]\n        fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            let allowance = self.allowance_impl(&from, &caller);\n            if allowance < value {\n                return Err(Error::InsufficientAllowance)\n            }\n            self.transfer_from_to(&from, &to, value)?;\n            // We checked that allowance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.allowances\n                .insert((&from, &caller), &(allowance - value));\n            Ok(())\n        }\n    }\n\n    #[ink(impl)]\n    impl Erc20 {\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `balance_of` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn balance_of_impl(&self, owner: &AccountId) -> Balance {\n            self.balances.get(owner).unwrap_or_default()\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `allowance` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn allowance_impl(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        fn transfer_from_to(\n            &mut self,\n            from: &AccountId,\n            to: &AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let from_balance = self.balance_of_impl(from);\n            if from_balance < value {\n                return Err(Error::InsufficientBalance)\n            }\n            // We checked that from_balance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.balances.insert(from, &(from_balance - value));\n            let to_balance = self.balance_of_impl(to);\n            self.balances\n                .insert(to, &(to_balance.checked_add(value).unwrap()));\n            self.env().emit_event(Transfer {\n                from: Some(*from),\n                to: Some(*to),\n                value,\n            });\n            Ok(())\n        }\n    }\n\n    /// Unit tests.\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use ink::{\n            env::hash::{\n                Blake2x256,\n                CryptoHash,\n                HashOutput,\n            },\n            primitives::Clear,\n        };\n\n        fn assert_transfer_event(\n            event: &ink::env::test::EmittedEvent,\n            expected_from: Option<AccountId>,\n            expected_to: Option<AccountId>,\n            expected_value: Balance,\n        ) {\n            let decoded_event =\n                <Transfer as ink::scale::Decode>::decode(&mut &event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            let Transfer { from, to, value } = decoded_event;\n            assert_eq!(from, expected_from, \"encountered invalid Transfer.from\");\n            assert_eq!(to, expected_to, \"encountered invalid Transfer.to\");\n            assert_eq!(value, expected_value, \"encountered invalid Trasfer.value\");\n\n            fn encoded_into_hash<T>(entity: T) -> Hash\n            where\n                T: ink::scale::Encode,\n            {\n                let mut result = Hash::CLEAR_HASH;\n                let len_result = result.as_ref().len();\n                let encoded = entity.encode();\n                let len_encoded = encoded.len();\n                if len_encoded <= len_result {\n                    result.as_mut()[..len_encoded].copy_from_slice(&encoded);\n                    return result\n                }\n                let mut hash_output =\n                    <<Blake2x256 as HashOutput>::Type as Default>::default();\n                <Blake2x256 as CryptoHash>::hash(&encoded, &mut hash_output);\n                let copy_len = core::cmp::min(hash_output.len(), len_result);\n                result.as_mut()[0..copy_len].copy_from_slice(&hash_output[0..copy_len]);\n                result\n            }\n\n            let mut expected_topics = Vec::new();\n            expected_topics.push(\n                ink::blake2x256!(\"Transfer(Option<AccountId>,Option<AccountId>,Balance)\")\n                    .into(),\n            );\n            if let Some(from) = expected_from {\n                expected_topics.push(encoded_into_hash(from));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            if let Some(to) = expected_to {\n                expected_topics.push(encoded_into_hash(to));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            expected_topics.push(encoded_into_hash(value));\n\n            for (n, (actual_topic, expected_topic)) in\n                event.topics.iter().zip(expected_topics).enumerate()\n            {\n                let topic = <Hash as ink::scale::Decode>::decode(&mut &actual_topic[..])\n                    .expect(\"encountered invalid topic encoding\");\n                assert_eq!(topic, expected_topic, \"encountered invalid topic at {n}\");\n            }\n        }\n\n        /// The default constructor does its job.\n        #[ink::test]\n        fn new_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n\n            // The `BaseErc20` trait has indeed been implemented.\n            assert_eq!(<Erc20 as BaseErc20>::total_supply(&erc20), initial_supply);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        /// The total supply was applied.\n        #[ink::test]\n        fn total_supply_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Get the token total supply.\n            assert_eq!(erc20.total_supply(), 100);\n        }\n\n        /// Get the actual balance of an account.\n        #[ink::test]\n        fn balance_of_works() {\n            // Constructor works\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Alice owns all the tokens on contract instantiation\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            // Bob does not owns tokens\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n        }\n\n        #[ink::test]\n        fn transfer_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            // Alice transfers 10 tokens to Bob.\n            assert_eq!(erc20.transfer(accounts.bob, 10), Ok(()));\n            // Bob owns 10 tokens.\n            assert_eq!(erc20.balance_of(accounts.bob), 10);\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 2);\n            // Check first transfer event related to ERC-20 instantiation.\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Check the second transfer event relating to the actual trasfer.\n            assert_transfer_event(\n                &emitted_events[1],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x02; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn invalid_transfer_should_fail() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            // Set Bob as caller\n            set_caller(accounts.bob);\n\n            // Bob fails to transfers 10 tokens to Eve.\n            assert_eq!(\n                erc20.transfer(accounts.eve, 10),\n                Err(Error::InsufficientBalance)\n            );\n            // Alice owns all the tokens.\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            assert_eq!(erc20.balance_of(accounts.eve), 0);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 1);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        #[ink::test]\n        fn transfer_from_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Bob fails to transfer tokens owned by Alice.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Err(Error::InsufficientAllowance)\n            );\n            // Alice approves Bob for token transfers on her behalf.\n            assert_eq!(erc20.approve(accounts.bob, 10), Ok(()));\n\n            // The approve event takes place.\n            assert_eq!(ink::env::test::recorded_events().count(), 2);\n\n            // Set Bob as caller.\n            set_caller(accounts.bob);\n\n            // Bob transfers tokens from Alice to Eve.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Ok(())\n            );\n            // Eve owns tokens.\n            assert_eq!(erc20.balance_of(accounts.eve), 10);\n\n            // Check all transfer events that happened during the previous calls:\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 3);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // The second event `emitted_events[1]` is an Approve event that we skip\n            // checking.\n            assert_transfer_event(\n                &emitted_events[2],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x05; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn allowance_must_not_change_on_failed_transfer() {\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Alice approves Bob for token transfers on her behalf.\n            let alice_balance = erc20.balance_of(accounts.alice);\n            let initial_allowance = alice_balance + 2;\n            assert_eq!(erc20.approve(accounts.bob, initial_allowance), Ok(()));\n\n            // Set Bob as caller.\n            set_caller(accounts.bob);\n\n            // Bob tries to transfer tokens from Alice to Eve.\n            let emitted_events_before = ink::env::test::recorded_events();\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, alice_balance + 1),\n                Err(Error::InsufficientBalance)\n            );\n            // Allowance must have stayed the same\n            assert_eq!(\n                erc20.allowance(accounts.alice, accounts.bob),\n                initial_allowance\n            );\n            // No more events must have been emitted\n            let emitted_events_after = ink::env::test::recorded_events();\n            assert_eq!(emitted_events_before.count(), emitted_events_after.count());\n        }\n\n        fn set_caller(sender: AccountId) {\n            ink::env::test::set_caller::<Environment>(sender);\n        }\n    }\n}\n"
    },
    {
      "name": "trait-flipper",
      "path": "trait-flipper/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::trait_definition]\npub trait Flip {\n    /// Flips the current value of the Flipper's boolean.\n    #[ink(message)]\n    fn flip(&mut self);\n\n    /// Returns the current value of the Flipper's boolean.\n    #[ink(message)]\n    fn get(&self) -> bool;\n}\n\n#[ink::contract]\npub mod flipper {\n    use super::Flip;\n\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Creates a new flipper smart contract initialized to `false`.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                value: Default::default(),\n            }\n        }\n    }\n\n    impl Flip for Flipper {\n        #[ink(message)]\n        fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        #[ink(message)]\n        fn get(&self) -> bool {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        fn default_works() {\n            let flipper = Flipper::new();\n            assert!(!flipper.get());\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut flipper = Flipper::new();\n            // Can call using universal call syntax using the trait.\n            assert!(!<Flipper as Flip>::get(&flipper));\n            <Flipper as Flip>::flip(&mut flipper);\n            // Normal call syntax possible to as long as the trait is in scope.\n            assert!(flipper.get());\n        }\n    }\n}\n"
    },
    {
      "name": "trait-incrementer",
      "path": "trait-incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod incrementer {\n    use traits::{\n        Increment,\n        Reset,\n    };\n\n    /// A concrete incrementer smart contract.\n    #[ink(storage)]\n    pub struct Incrementer {\n        value: u64,\n    }\n\n    impl Incrementer {\n        /// Creates a new incrementer smart contract initialized with zero.\n        #[ink(constructor)]\n        pub fn new(init_value: u64) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Increases the value of the incrementer by an amount.\n        #[ink(message)]\n        pub fn inc_by(&mut self, delta: u64) {\n            self.value = self.value.checked_add(delta).unwrap();\n        }\n    }\n\n    impl Increment for Incrementer {\n        #[ink(message)]\n        fn inc(&mut self) {\n            self.inc_by(1)\n        }\n\n        #[ink(message)]\n        fn get(&self) -> u64 {\n            self.value\n        }\n    }\n\n    impl Reset for Incrementer {\n        #[ink(message)]\n        fn reset(&mut self) {\n            self.value = 0;\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn default_works() {\n            let incrementer = Incrementer::new(0);\n            assert_eq!(incrementer.get(), 0);\n        }\n\n        #[test]\n        fn it_works() {\n            let mut incrementer = Incrementer::new(0);\n            // Can call using universal call syntax using the trait.\n            assert_eq!(<Incrementer as Increment>::get(&incrementer), 0);\n            <Incrementer as Increment>::inc(&mut incrementer);\n            // Normal call syntax possible to as long as the trait is in scope.\n            assert_eq!(incrementer.get(), 1);\n        }\n    }\n}\n"
    },
    {
      "name": "traits",
      "path": "trait-incrementer/traits/lib.rs",
      "code": "// Copyright (C) Use Ink (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n//! Traits are extracted into a separate crate to show how the user can import\n//! several foreign traits and implement those for the contract.\n\n/// Allows to increment and get the current value.\n#[ink::trait_definition]\npub trait Increment {\n    /// Increments the current value of the implementer by one (1).\n    #[ink(message)]\n    fn inc(&mut self);\n\n    /// Returns the current value of the implementer.\n    #[ink(message)]\n    fn get(&self) -> u64;\n}\n\n/// Allows to reset the current value.\n#[ink::trait_definition]\npub trait Reset {\n    /// Resets the current value to zero.\n    #[ink(message)]\n    fn reset(&mut self);\n}\n"
    },
    {
      "name": "delegatee",
      "path": "upgradeable-contracts/delegator/delegatee/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delegatee {\n    use ink::storage::{\n        traits::ManualKey,\n        Mapping,\n    };\n    #[ink(storage)]\n    pub struct Delegatee {\n        addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n        counter: i32,\n        // Uncommenting below line will break storage compatibility.\n        // flag: bool,\n    }\n\n    impl Delegatee {\n        /// When using the delegate call. You only upload the code of the delegatee\n        /// contract. However, the code and storage do not get initialized.\n        ///\n        /// Because of this. The constructor actually never gets called.\n        #[allow(clippy::new_without_default)]\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                \"Constructors are not called when upgrading using `set_code_hash`.\"\n            )\n        }\n\n        /// Increments the current value.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.counter = self.counter.checked_add(2).unwrap();\n        }\n\n        /// Adds current value of counter to the `addresses`\n        #[ink(message)]\n        pub fn append_address_value(&mut self) {\n            let caller = self.env().caller();\n            self.addresses.insert(caller, &self.counter);\n        }\n    }\n}\n"
    },
    {
      "name": "delegatee2",
      "path": "upgradeable-contracts/delegator/delegatee2/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delegatee2 {\n    use ink::storage::{\n        traits::ManualKey,\n        Mapping,\n    };\n    #[ink(storage)]\n    pub struct Delegatee2 {\n        addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n        counter: i32,\n    }\n\n    impl Delegatee2 {\n        #[allow(clippy::new_without_default)]\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                \"Constructors are not called when upgrading using `set_code_hash`.\"\n            )\n        }\n\n        /// Increments the current value.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.counter = self.counter.checked_add(3).unwrap();\n        }\n\n        /// Adds current value of counter to the `addresses`\n        #[ink(message)]\n        pub fn append_address_value(&mut self) {\n            let caller = self.env().caller();\n            self.addresses.insert(caller, &self.counter);\n        }\n    }\n}\n"
    },
    {
      "name": "delegator",
      "path": "upgradeable-contracts/delegator/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delegator {\n    use ink::{\n        env::{\n            call::{\n                build_call,\n                ExecutionInput,\n                Selector,\n            },\n            CallFlags,\n            DefaultEnvironment,\n        },\n        storage::{\n            traits::ManualKey,\n            Lazy,\n            Mapping,\n        },\n    };\n\n    #[ink(storage)]\n    pub struct Delegator {\n        addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n        counter: i32,\n        delegate_to: Lazy<Hash>,\n    }\n\n    impl Delegator {\n        /// Creates a new delegator smart contract with an initial value, and the hash of\n        /// the contract code to delegate to.\n        ///\n        /// Additionally, this code hash will be locked to prevent its deletion, since\n        /// this contract depends on it.\n        #[ink(constructor)]\n        pub fn new(init_value: i32, hash: Hash) -> Self {\n            let v = Mapping::new();\n\n            // Initialize the hash of the contract to delegate to.\n            // Adds a delegate dependency lock, ensuring that the delegated to code cannot\n            // be removed.\n            let mut delegate_to = Lazy::new();\n            delegate_to.set(&hash);\n            Self::env().lock_delegate_dependency(&hash);\n\n            Self {\n                addresses: v,\n                counter: init_value,\n                delegate_to,\n            }\n        }\n\n        /// Update the hash of the contract to delegate to.\n        /// - Unlocks the old delegate dependency, releasing the deposit and allowing old\n        ///   delegated to code to be removed.\n        /// - Adds a new delegate dependency lock, ensuring that the new delegated to code\n        ///   cannot be removed.\n        #[ink(message)]\n        pub fn update_delegate_to(&mut self, hash: Hash) {\n            if let Some(old_hash) = self.delegate_to.get() {\n                self.env().unlock_delegate_dependency(&old_hash)\n            }\n            self.env().lock_delegate_dependency(&hash);\n            self.delegate_to.set(&hash);\n        }\n\n        /// Increment the current value using delegate call.\n        #[ink(message)]\n        pub fn inc_delegate(&mut self) {\n            let selector = ink::selector_bytes!(\"inc\");\n            let _ = build_call::<DefaultEnvironment>()\n                .delegate(self.delegate_to())\n                // We specify `CallFlags::TAIL_CALL` to use the delegatee last memory frame\n                // as the end of the execution cycle.\n                // So any mutations to `Packed` types, made by delegatee,\n                // will be flushed to storage.\n                //\n                // If we don't specify this flag.\n                // The storage state before the delegate call will be flushed to storage instead.\n                // See https://substrate.stackexchange.com/questions/3336/i-found-set-allow-reentry-may-have-some-problems/3352#3352\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<()>()\n                .try_invoke();\n        }\n\n        /// Adds entry to `addresses` using delegate call.\n        /// Note that we don't need `CallFlags::TAIL_CALL` flag\n        /// because `Mapping` updates the storage instantly on-demand.\n        #[ink(message)]\n        pub fn add_entry_delegate(&mut self) {\n            let selector = ink::selector_bytes!(\"append_address_value\");\n            let _ = build_call::<DefaultEnvironment>()\n                .delegate(self.delegate_to())\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<()>()\n                .try_invoke();\n        }\n\n        /// Returns the current value of the counter.\n        #[ink(message)]\n        pub fn get_counter(&self) -> i32 {\n            self.counter\n        }\n\n        /// Returns the current value of the address.\n        #[ink(message)]\n        pub fn get_value(&self, address: AccountId) -> (AccountId, Option<i32>) {\n            (self.env().caller(), self.addresses.get(address))\n        }\n\n        fn delegate_to(&self) -> Hash {\n            self.delegate_to\n                .get()\n                .expect(\"delegate_to always has a value\")\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::{\n            ChainBackend,\n            ContractsBackend,\n        };\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn e2e_counter_mutated<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            let mut constructor = DelegatorRef::new(0, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.inc_delegate();\n\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"delegate call failed.\");\n\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"second delegate call failed.\");\n\n            // then\n            let expected_value = 4;\n            let call_builder = contract.call_builder::<Delegator>();\n\n            let call_get = call_builder.get_counter();\n            let call_get_result = client\n                .call(&origin, &call_get)\n                .dry_run()\n                .await?\n                .return_value();\n\n            // This fails\n            assert_eq!(\n                call_get_result, expected_value,\n                \"Decoded an unexpected value from the call.\"\n            );\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn e2e_mapping_mutated<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            // given\n            let mut constructor = DelegatorRef::new(10, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.add_entry_delegate();\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"delegate call failed.\");\n\n            // then\n\n            // because we initialize the counter with `10` we expect this value be\n            // assigned to Alice.\n            let expected_value = 10;\n            // Alice's address\n            let address = AccountId::from(origin.public_key().to_account_id().0);\n\n            let call_get_value = call_builder.get_value(address);\n            let call_get_result = client\n                .call(&origin, &call_get_value)\n                .submit()\n                .await\n                .unwrap()\n                .return_value();\n\n            assert_eq!(\n                call_get_result,\n                (address, Some(expected_value)),\n                \"Decoded an unexpected value from the call.\"\n            );\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn update_delegate<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            let code_hash2 = client\n                .upload(\"delegatee2\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee2` failed\")\n                .code_hash;\n\n            let mut constructor = DelegatorRef::new(10, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.update_delegate_to(code_hash2);\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"update_delegate_to failed.\");\n\n            // then\n\n            // remove the original delegatee code.\n            // should succeed because the delegate dependency has been removed.\n            let original_code_removed =\n                client.remove_code(&origin, code_hash).submit().await;\n            assert!(original_code_removed.is_ok());\n\n            // attempt to remove the new delegatee code.\n            // should fail because of the delegate dependency.\n            let new_code_removed = client.remove_code(&origin, code_hash2).submit().await;\n            assert!(new_code_removed.is_err());\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "set-code-hash",
      "path": "upgradeable-contracts/set-code-hash/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n//! Demonstrates how to use [`set_code_hash`](https://docs.rs/ink_env/latest/ink_env/fn.set_code_hash.html)\n//! to swap out the `code_hash` of an on-chain contract.\n//!\n//! We will swap the code of our `Incrementer` contract with that of the an `Incrementer`\n//! found in the `updated_incrementer` folder.\n//!\n//! See the included End-to-End tests an example update workflow.\n\n#[ink::contract]\npub mod incrementer {\n\n    /// Track a counter in storage.\n    ///\n    /// # Note\n    ///\n    /// Is is important to realize that after the call to `set_code_hash` the contract's\n    /// storage remains the same.\n    ///\n    /// If you change the storage layout in your storage struct you may introduce\n    /// undefined behavior to your contract!\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Incrementer {\n        count: u32,\n    }\n\n    impl Incrementer {\n        /// Creates a new counter smart contract initialized with the given base value.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        /// Increments the counter value which is stored in the contract's storage.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.count = self.count.checked_add(1).unwrap();\n            ink::env::debug_println!(\n                \"The new count is {}, it was modified using the original contract code.\",\n                self.count\n            );\n        }\n\n        /// Returns the counter value which is stored in this contract's storage.\n        #[ink(message)]\n        pub fn get(&self) -> u32 {\n            self.count\n        }\n\n        /// Modifies the code which is used to execute calls to this contract address\n        /// (`AccountId`).\n        ///\n        /// We use this to upgrade the contract logic. We don't do any authorization here,\n        /// any caller can execute this method.\n        ///\n        /// In a production contract you would do some authorization here!\n        #[ink(message)]\n        pub fn set_code(&mut self, code_hash: Hash) {\n            self.env().set_code_hash(&code_hash).unwrap_or_else(|err| {\n                panic!(\"Failed to `set_code_hash` to {code_hash:?} due to {err:?}\")\n            });\n            ink::env::debug_println!(\"Switched code hash to {:?}.\", code_hash);\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn set_code_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // Given\n            let mut constructor = IncrementerRef::new();\n            let contract = client\n                .instantiate(\"incrementer\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Incrementer>();\n\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::alice(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), 0));\n\n            let inc = call_builder.inc();\n            let _inc_result = client\n                .call(&ink_e2e::alice(), &inc)\n                .submit()\n                .await\n                .expect(\"`inc` failed\");\n\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::alice(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), 1));\n\n            // When\n            let new_code_hash = client\n                .upload(\"updated_incrementer\", &ink_e2e::alice())\n                .submit()\n                .await\n                .expect(\"uploading `updated_incrementer` failed\")\n                .code_hash;\n\n            let new_code_hash = new_code_hash.as_ref().try_into().unwrap();\n            let set_code = call_builder.set_code(new_code_hash);\n\n            let _set_code_result = client\n                .call(&ink_e2e::alice(), &set_code)\n                .submit()\n                .await\n                .expect(\"`set_code` failed\");\n\n            // Then\n            // Note that our contract's `AccountId` (so `contract_acc_id`) has stayed the\n            // same between updates!\n            let inc = call_builder.inc();\n\n            let _inc_result = client\n                .call(&ink_e2e::alice(), &inc)\n                .submit()\n                .await\n                .expect(\"`inc` failed\");\n\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::alice(), &get).dry_run().await?;\n\n            // Remember, we updated our incrementer contract to increment by `4`.\n            assert!(matches!(get_res.return_value(), 5));\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "updated-incrementer",
      "path": "upgradeable-contracts/set-code-hash/updated-incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod incrementer {\n\n    /// Track a counter in storage.\n    ///\n    /// # Note\n    ///\n    /// We have kept the same storage layout as in our original `incrementer` contract.\n    ///\n    /// Had we changed `count` to, for example, an `AccountId` we would end up with\n    /// undefined behaviour in our contract.\n    #[ink(storage)]\n    pub struct Incrementer {\n        count: u32,\n    }\n\n    impl Incrementer {\n        /// Creates a new counter smart contract initialized with the given base value.\n        ///\n        /// # Note\n        ///\n        /// When upgrading using the `set_code_hash` workflow we only need to point to a\n        /// contract's uploaded code hash, **not** an instantiated contract's\n        /// `AccountId`.\n        ///\n        /// Because of this we will never actually call the constructor of this contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                \"Constructors are not called when upgrading using `set_code_hash`.\"\n            )\n        }\n\n        /// Increments the counter value which is stored in the contract's storage.\n        ///\n        /// # Note\n        ///\n        /// We use a different step size (4) here than in the original `incrementer`.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.count = self.count.checked_add(4).unwrap();\n            ink::env::debug_println!(\"The new count is {}, it was modified using the updated `new_incrementer` code.\", self.count);\n        }\n\n        /// Returns the counter value which is stored in this contract's storage.\n        #[ink(message)]\n        pub fn get(&self) -> u32 {\n            self.count\n        }\n\n        /// Modifies the code which is used to execute calls to this contract address\n        /// (`AccountId`).\n        ///\n        /// We use this to upgrade the contract logic. We don't do any authorization here,\n        /// any caller can execute this method.\n        ///\n        /// In a production contract you would do some authorization here!\n        #[ink(message)]\n        pub fn set_code(&mut self, code_hash: Hash) {\n            self.env().set_code_hash(&code_hash).unwrap_or_else(|err| {\n                panic!(\"Failed to `set_code_hash` to {code_hash:?} due to {err:?}\")\n            });\n            ink::env::debug_println!(\"Switched code hash to {:?}.\", code_hash);\n        }\n    }\n}\n"
    },
    {
      "name": "set-code-hash-migration",
      "path": "upgradeable-contracts/set-code-hash-migration/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n//! Demonstrates how to use [`set_code_hash`](https://docs.rs/ink_env/latest/ink_env/fn.set_code_hash.html)\n//! to swap out the `code_hash` of an on-chain contract.\n//!\n//! We will swap the code of our `Incrementer` contract with that of the `Incrementer`\n//! found in the `updated_incrementer` folder.\n//!\n//! See the included End-to-End tests an example update workflow.\n\n#[ink::contract]\npub mod incrementer {\n    /// Track a counter in storage.\n    ///\n    /// # Note\n    ///\n    /// Is is important to realize that after the call to `set_code_hash` the contract's\n    /// storage remains the same.\n    ///\n    /// If you change the storage layout in your storage struct you may introduce\n    /// undefined behavior to your contract!\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Incrementer {\n        count: u32,\n    }\n\n    impl Incrementer {\n        /// Creates a new counter smart contract initialized with the given base value.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        /// Increments the counter value which is stored in the contract's storage.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.count = self.count.checked_add(1).unwrap();\n            ink::env::debug_println!(\n                \"The new count is {}, it was modified using the original contract code.\",\n                self.count\n            );\n        }\n\n        /// Returns the counter value which is stored in this contract's storage.\n        #[ink(message)]\n        pub fn get(&self) -> u32 {\n            self.count\n        }\n\n        /// Modifies the code which is used to execute calls to this contract address\n        /// (`AccountId`).\n        ///\n        /// We use this to upgrade the contract logic. We don't do any authorization here,\n        /// any caller can execute this method.\n        ///\n        /// In a production contract you would do some authorization here!\n        #[ink(message)]\n        pub fn set_code(&mut self, code_hash: Hash) {\n            self.env().set_code_hash(&code_hash).unwrap_or_else(|err| {\n                panic!(\"Failed to `set_code_hash` to {code_hash:?} due to {err:?}\")\n            });\n            ink::env::debug_println!(\"Switched code hash to {:?}.\", code_hash);\n        }\n    }\n}\n\n#[cfg(all(test, feature = \"e2e-tests\"))]\nmod e2e_tests;\n"
    },
    {
      "name": "migration",
      "path": "upgradeable-contracts/set-code-hash-migration/migration/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod incrementer {\n\n    /// Storage struct matches exactly that of the original `incrementer` contract, from\n    /// which we are migrating.\n    #[ink(storage)]\n    pub struct Incrementer {\n        count: u32,\n    }\n\n    #[ink::storage_item]\n    pub struct IncrementerNew {\n        count: u64,\n        inc_by: u8,\n    }\n\n    impl Incrementer {\n        /// Creates a new counter smart contract initialized with the given base value.\n        ///\n        /// # Note\n        ///\n        /// When upgrading using the `set_code_hash` workflow we only need to point to a\n        /// contract's uploaded code hash, **not** an instantiated contract's\n        /// `AccountId`.\n        ///\n        /// Because of this we will never actually call the constructor of this contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                \"Constructors are not called when upgrading using `set_code_hash`.\"\n            )\n        }\n\n        /// Run the migration to the data layout for the upgraded contract.\n        /// Once the storage migration has successfully completed, the contract will be\n        /// upgraded to the supplied code hash.\n        ///\n        /// In a production contract you would do some authorization here!\n        ///\n        /// # Note\n        ///\n        /// This function necessarily accepts a `&self` instead of a `&mut self` because\n        /// we are modifying storage directly for the migration.\n        ///\n        /// The `self` in `&mut self` is the original `Incrementer` storage struct, and\n        /// would be implicitly written to storage following the function execution,\n        /// overwriting the migrated storage.\n        #[ink(message)]\n        pub fn migrate(&self, inc_by: u8, code_hash: Hash) {\n            let incrementer_new = IncrementerNew {\n                count: self.count as u64,\n                inc_by,\n            };\n\n            // overwrite the original storage struct with the migrated storage struct,\n            // which has a layout compatible with the new contract code.\n            const STORAGE_KEY: u32 =\n                <Incrementer as ink::storage::traits::StorageKey>::KEY;\n            ink::env::set_contract_storage(&STORAGE_KEY, &incrementer_new);\n\n            ink::env::set_code_hash::<<Self as ink::env::ContractEnv>::Env>(&code_hash)\n                .unwrap_or_else(|err| {\n                    panic!(\"Failed to `set_code_hash` to {code_hash:?} due to {err:?}\")\n                })\n        }\n    }\n}\n"
    },
    {
      "name": "updated-incrementer",
      "path": "upgradeable-contracts/set-code-hash-migration/updated-incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n#![allow(clippy::new_without_default)]\n\n#[ink::contract]\npub mod incrementer {\n\n    /// Track a counter in storage.\n    ///\n    /// # Note\n    ///\n    /// We have changed the storage layout:\n    /// - `count` is now a `u64` instead of a `u32`.\n    /// - We have added a new field `inc_by` which controls how many to increment by.\n    #[ink(storage)]\n    pub struct Incrementer {\n        count: u64,\n        inc_by: u8,\n    }\n\n    impl Incrementer {\n        /// Creates a new counter smart contract initialized with the given base value.\n        ///\n        /// # Note\n        ///\n        /// When upgrading using the `set_code_hash` workflow we only need to point to a\n        /// contract's uploaded code hash, **not** an instantiated contract's\n        /// `AccountId`.\n        ///\n        /// Because of this we will never actually call the constructor of this contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                \"Constructors are not called when upgrading using `set_code_hash`.\"\n            )\n        }\n\n        /// Increments the counter value which is stored in the contract's storage.\n        ///\n        /// # Note\n        ///\n        /// In this upgraded contract the value is incremented by the value in the\n        /// `inc_by` field.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.count = self.count.checked_add(self.inc_by.into()).unwrap();\n        }\n\n        /// Set the value by which the counter will be incremented.\n        #[ink(message)]\n        pub fn set_inc_by(&mut self, inc_by: u8) {\n            self.inc_by = inc_by;\n        }\n\n        /// Returns the counter value which is stored in this contract's storage.\n        #[ink(message)]\n        pub fn get(&self) -> u64 {\n            self.count\n        }\n\n        /// Modifies the code which is used to execute calls to this contract address\n        /// (`AccountId`).\n        ///\n        /// We use this to upgrade the contract logic. We don't do any authorization here,\n        /// any caller can execute this method.\n        ///\n        /// In a production contract you would do some authorization here!\n        #[ink(message)]\n        pub fn set_code(&mut self, code_hash: Hash) {\n            self.env().set_code_hash(&code_hash).unwrap_or_else(|err| {\n                panic!(\"Failed to `set_code_hash` to {code_hash:?} due to {err:?}\")\n            });\n            ink::env::debug_println!(\"Switched code hash to {:?}.\", code_hash);\n        }\n    }\n}\n"
    },
    {
      "name": "vesting",
      "path": "vesting/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod vesting_contract {\n\n    #[ink(storage)]\n    pub struct VestingContract {\n        releasable_balance: Balance,\n        released_balance: Balance,\n        duration_time: Timestamp,\n        start_time: Timestamp,\n        beneficiary: AccountId,\n        owner: AccountId,\n    }\n\n    /// Error for when the beneficiary is a zero address.\n    /// & Error for when the releasable balance is zero.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        InvalidBeneficiary,\n        ZeroReleasableBalance,\n    }\n\n    /// To emit events when a release is made.\n    #[ink(event)]\n    pub struct Released {\n        value: Balance,\n        to: AccountId,\n    }\n\n    /// ## This is to set the following during contract deployment:\n    /// - beneficiary: the account that will receive the tokens\n    /// - duration_time: duration of the vesting period,\n    ///   please note that this is in seconds\n    /// - start_time: the time (as Unix time) at which point\n    ///   vesting starts\n    /// - owner: the account that can release the tokens\n    /// - releasable_balance: the initial amount of tokens vested\n    /// - released_balance: the initial amount of tokens released\n    ///\n    /// # Note:\n    /// The beneficiary cannot be the zero address.\n    impl VestingContract {\n        #[ink(constructor, payable)]\n        pub fn new(\n            beneficiary: AccountId,\n            duration_time_in_sec: Timestamp,\n        ) -> Result<Self, Error> {\n            if beneficiary == AccountId::from([0x0; 32]) {\n                return Err(Error::InvalidBeneficiary)\n            }\n\n            // This is multiplied by 1000 to conform to the\n            // Timestamp fomat in ink.\n            let duration_time = duration_time_in_sec.checked_mul(1000).unwrap();\n\n            let start_time = Self::env().block_timestamp();\n            let owner = Self::env().caller();\n            let releasable_balance = 0;\n            let released_balance = 0;\n\n            Ok(Self {\n                duration_time,\n                start_time,\n                beneficiary,\n                owner,\n                releasable_balance,\n                released_balance,\n            })\n        }\n\n        /// This returns current block timestamp.\n        pub fn time_now(&self) -> Timestamp {\n            self.env().block_timestamp()\n        }\n\n        /// This returns this contract balance.\n        #[ink(message)]\n        pub fn this_contract_balance(&self) -> Balance {\n            self.env().balance()\n        }\n\n        /// This returns the beneficiary wallet addr.\n        #[ink(message)]\n        pub fn beneficiary(&self) -> AccountId {\n            self.beneficiary\n        }\n\n        /// This returns the time at which point\n        /// vesting starts.\n        #[ink(message)]\n        pub fn start_time(&self) -> Timestamp {\n            self.start_time\n        }\n\n        /// This returns the duration of the vesting\n        /// period, in seconds.\n        #[ink(message)]\n        pub fn duration_time(&self) -> Timestamp {\n            self.duration_time\n        }\n\n        /// This returns the time at which point\n        /// vesting ends.\n        #[ink(message)]\n        pub fn end_time(&self) -> Timestamp {\n            self.start_time().checked_add(self.duration_time()).unwrap()\n        }\n\n        /// This returns the amount of time remaining\n        /// until the end of the vesting period.\n        #[ink(message)]\n        pub fn time_remaining(&self) -> Timestamp {\n            if self.time_now() < self.end_time() {\n                self.end_time().checked_sub(self.time_now()).unwrap()\n            } else {\n                0\n            }\n        }\n\n        /// This returns the amount of native token that\n        /// has already vested.\n        #[ink(message)]\n        pub fn released_balance(&self) -> Balance {\n            self.released_balance\n        }\n\n        /// This returns the amount of native token that\n        /// is currently available for release.\n        #[ink(message)]\n        pub fn releasable_balance(&self) -> Balance {\n            (self.vested_amount() as Balance)\n                .checked_sub(self.released_balance())\n                .unwrap()\n        }\n\n        /// This calculates the amount that has already vested\n        /// but hasn't been released from the contract yet.\n        #[ink(message)]\n        pub fn vested_amount(&self) -> Balance {\n            self.vesting_schedule(self.this_contract_balance(), self.time_now())\n        }\n\n        /// This sends the releasable balance to the beneficiary.\n        /// wallet address; no matter who triggers the release.\n        #[ink(message)]\n        pub fn release(&mut self) -> Result<(), Error> {\n            let releasable = self.releasable_balance();\n            if releasable == 0 {\n                return Err(Error::ZeroReleasableBalance)\n            }\n\n            self.released_balance =\n                self.released_balance.checked_add(releasable).unwrap();\n            self.env()\n                .transfer(self.beneficiary, releasable)\n                .expect(\"Transfer failed during release\");\n\n            self.env().emit_event(Released {\n                value: releasable,\n                to: self.beneficiary,\n            });\n\n            Ok(())\n        }\n\n        /// This calculates the amount of tokens that have vested up\n        /// to the given current_time.\n        ///\n        /// The vesting schedule is linear, meaning tokens are\n        /// released evenly over the vesting duration.\n        ///\n        /// # Parameters:\n        /// - total_allocation: The total number of tokens\n        ///   allocated for vesting.\n        /// - current_time: The current timestamp for which\n        ///   we want to check the vested amount.\n        ///\n        /// # Returns:\n        /// - `0` if the current_time is before the vesting start time.\n        /// - total_allocation if the current_time is after the vesting\n        ///   end time or at least equal to it.\n        /// - A prorated amount based on how much time has passed since\n        ///   the start of the vesting period if the `current_time` is\n        ///   during the vesting period.\n        ///\n        /// # Example:\n        /// If the vesting duration is 200 seconds and 100 seconds have\n        /// passed since the start time, then 50% of the total_allocation\n        /// would have vested.\n        pub fn vesting_schedule(\n            &self,\n            total_allocation: Balance,\n            current_time: Timestamp,\n        ) -> Balance {\n            if current_time < self.start_time() {\n                0\n            } else if current_time >= self.end_time() {\n                return total_allocation\n            } else {\n                return (total_allocation.checked_mul(\n                    (current_time.checked_sub(self.start_time()).unwrap()) as Balance,\n                ))\n                .unwrap()\n                .checked_div(self.duration_time() as Balance)\n                .unwrap()\n            }\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        /// Checking that the default constructor does its job.\n        #[ink::test]\n        fn new_creates_contract_with_correct_values() {\n            let contract =\n                VestingContract::new(AccountId::from([0x01; 32]), 200).unwrap();\n\n            assert_eq!(contract.beneficiary(), AccountId::from([0x01; 32]));\n            assert_eq!(contract.duration_time(), 200 * 1000);\n            assert_eq!(contract.released_balance(), 0);\n            assert_eq!(contract.releasable_balance(), 0);\n        }\n\n        /// There should be some time remaining before the vesting period ends.\n        #[ink::test]\n        fn time_remaining_works() {\n            let contract =\n                VestingContract::new(AccountId::from([0x01; 32]), 200).unwrap();\n            assert!(contract.time_remaining() > 0);\n        }\n\n        /// # Checking that tokens cannot be released before\n        /// the vesting period:\n        ///     - Trying to release tokens before the vesting period\n        ///       has ended, it will return an error.\n        ///     - The released_balance should remain 0 since no tokens\n        ///       were released.\n        #[ink::test]\n        fn release_before_vesting_period_fails() {\n            let mut contract =\n                VestingContract::new(AccountId::from([0x01; 32]), 200).unwrap();\n\n            assert_eq!(contract.release(), Err(Error::ZeroReleasableBalance));\n            assert_eq!(contract.released_balance(), 0);\n        }\n\n        /// # Checking if tokens can be released after the vesting period:\n        ///     - Setting the duration_time to 0 to simulate the end of\n        ///       the vesting period.\n        ///     - And then simulate a deposit into the contract.\n        ///     - After releasing, the released_balance should match the\n        ///       amount we simulated as a deposit.\n        #[ink::test]\n        fn release_after_vesting_period_works() {\n            let mut contract =\n                VestingContract::new(AccountId::from([0x01; 32]), 0).unwrap();\n            contract.releasable_balance += 1000000;\n\n            assert_eq!(contract.release(), Ok(()));\n            assert_eq!(contract.released_balance(), 1000000);\n        }\n\n        /// # Checking the vesting_schedule function for a specific behavior:\n        ///     - Given a total allocation and a current time halfway through\n        ///       the vesting period, the vested amount should be half of\n        ///       the total allocation.\n        #[ink::test]\n        fn vesting_schedule_works() {\n            let contract =\n                VestingContract::new(AccountId::from([0x01; 32]), 200).unwrap();\n\n            assert_eq!(\n                contract.vesting_schedule(1000, contract.start_time() + 100 * 1000),\n                500\n            );\n        }\n    }\n}\n"
    },
    {
      "name": "wildcard-selector",
      "path": "wildcard-selector/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wildcard_selector {\n    use ink::prelude::string::String;\n\n    #[ink(storage)]\n    pub struct WildcardSelector {}\n\n    impl WildcardSelector {\n        /// Creates a new wildcard selector smart contract.\n        #[ink(constructor)]\n        #[allow(clippy::new_without_default)]\n        pub fn new() -> Self {\n            Self {}\n        }\n\n        /// Wildcard selector handles messages with any selector.\n        #[ink(message, selector = _)]\n        pub fn wildcard(&mut self) {\n            let (_selector, _message) =\n                ink::env::decode_input::<([u8; 4], String)>().unwrap();\n            ink::env::debug_println!(\n                \"Wildcard selector: {:?}, message: {}\",\n                _selector,\n                _message\n            );\n        }\n\n        /// Wildcard complement handles messages with a well-known reserved selector.\n        #[ink(message, selector = @)]\n        pub fn wildcard_complement(&mut self, _message: String) {\n            ink::env::debug_println!(\"Wildcard complement message: {}\", _message);\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        use ink::env::call::utils::{\n            Argument,\n            ArgumentList,\n            EmptyArgumentList,\n        };\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n        type Environment = <WildcardSelectorRef as ink::env::ContractEnv>::Env;\n\n        fn build_message(\n            account_id: AccountId,\n            selector: [u8; 4],\n            message: String,\n        ) -> ink_e2e::CallBuilderFinal<\n            Environment,\n            ArgumentList<Argument<String>, EmptyArgumentList>,\n            (),\n        > {\n            ink::env::call::build_call::<Environment>()\n                .call(account_id)\n                .exec_input(\n                    ink::env::call::ExecutionInput::new(ink::env::call::Selector::new(\n                        selector,\n                    ))\n                    .push_arg(message),\n                )\n                .returns::<()>()\n        }\n\n        #[ink_e2e::test]\n        async fn arbitrary_selectors_handled_by_wildcard<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = WildcardSelectorRef::new();\n            let contract_acc_id = client\n                .instantiate(\"wildcard_selector\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\")\n                .account_id;\n\n            // when\n            const ARBITRARY_SELECTOR: [u8; 4] = [0xF9, 0xF9, 0xF9, 0xF9];\n            let wildcard_message = \"WILDCARD_MESSAGE 1\".to_string();\n            let wildcard = build_message(\n                contract_acc_id,\n                ARBITRARY_SELECTOR,\n                wildcard_message.clone(),\n            );\n\n            let result = client\n                .call(&ink_e2e::bob(), &wildcard)\n                .submit()\n                .await\n                .expect(\"wildcard failed\");\n\n            const ARBITRARY_SELECTOR_2: [u8; 4] = [0x01, 0x23, 0x45, 0x67];\n            let wildcard_message2 = \"WILDCARD_MESSAGE 2\".to_string();\n            let wildcard2 = build_message(\n                contract_acc_id,\n                ARBITRARY_SELECTOR_2,\n                wildcard_message2.clone(),\n            );\n\n            let result2 = client\n                .call(&ink_e2e::bob(), &wildcard2)\n                .submit()\n                .await\n                .expect(\"wildcard failed\");\n\n            // then\n            assert!(result.debug_message().contains(&format!(\n                \"Wildcard selector: {:?}, message: {}\",\n                ARBITRARY_SELECTOR, wildcard_message\n            )));\n\n            assert!(result2.debug_message().contains(&format!(\n                \"Wildcard selector: {:?}, message: {}\",\n                ARBITRARY_SELECTOR_2, wildcard_message2\n            )));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn wildcard_complement_works<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let mut constructor = WildcardSelectorRef::new();\n            let contract_acc_id = client\n                .instantiate(\"wildcard_selector\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\")\n                .account_id;\n\n            // when\n            let wildcard_complement_message = \"WILDCARD COMPLEMENT MESSAGE\".to_string();\n            let wildcard = build_message(\n                contract_acc_id,\n                ink::IIP2_WILDCARD_COMPLEMENT_SELECTOR,\n                wildcard_complement_message.clone(),\n            );\n\n            let result = client\n                .call(&ink_e2e::bob(), &wildcard)\n                .submit()\n                .await\n                .expect(\"wildcard failed\");\n\n            // then\n            assert!(result.debug_message().contains(&format!(\n                \"Wildcard complement message: {}\",\n                wildcard_complement_message\n            )));\n\n            Ok(())\n        }\n    }\n}\n"
    },
    {
      "name": "flipper",
      "path": "workspace-contracts/flipper/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Creates a new flipper smart contract initialized with the given value.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Creates a new flipper smart contract initialized to `false`.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Flips the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n}\n"
    },
    {
      "name": "incrementer",
      "path": "workspace-contracts/incrementer/lib.rs",
      "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod incrementer {\n    #[ink(storage)]\n    pub struct Incrementer {\n        value: i32,\n    }\n\n    impl Incrementer {\n        #[ink(constructor)]\n        pub fn new(init_value: i32) -> Self {\n            Self { value: init_value }\n        }\n\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        #[ink(message)]\n        pub fn inc(&mut self, by: i32) {\n            self.value = self.value.saturating_add(by);\n        }\n\n        #[ink(message)]\n        pub fn get(&self) -> i32 {\n            self.value\n        }\n    }\n}\n"
    }
  ],
  "totalContracts": 59,
  "description": "A collection of ink! smart contract examples with their source code"
}